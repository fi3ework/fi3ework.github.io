<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>firework&#39;s Studio</title>
  
  <subtitle>it&#39;s better to burn out than to fade away</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://fi3ework.github.io/"/>
  <updated>2018-01-28T09:41:24.751Z</updated>
  <id>https://fi3ework.github.io/</id>
  
  <author>
    <name>Wee</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://fi3ework.github.io/2018-01-28/fout/"/>
    <id>https://fi3ework.github.io/2018-01-28/fout/</id>
    <published>2018-01-28T07:20:12.199Z</published>
    <updated>2018-01-28T09:41:24.751Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用VSCode调试Webpack</title>
    <link href="https://fi3ework.github.io/2018-01-12/debug-webpack-with-vscode/"/>
    <id>https://fi3ework.github.io/2018-01-12/debug-webpack-with-vscode/</id>
    <published>2018-01-12T08:38:27.000Z</published>
    <updated>2018-01-14T15:30:30.045Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>使用VSCode来调试经过Webpack打包和Babel转义之后的代码。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ol><li>安装<a href="https://marketplace.visualstudio.com/items?itemName=msjsdiag.debugger-for-chrome" target="_blank" rel="external">Debugger for Chrome</a>这个VSCode的插件</li><li>Chrome</li></ol><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><ol><li><p>新建一个launch.json，可参考<a href="https://www.jianshu.com/p/9e18230839ef" target="_blank" rel="external">此篇文章</a></p></li><li><p><strong>重点来了，如何配置launch.json</strong></p><p>先把我的配置放上来</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  // 使用 IntelliSense 了解相关属性。 </div><div class="line">  // 悬停以查看现有属性的描述。</div><div class="line">  // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</div><div class="line">  "version": "0.2.0",</div><div class="line">  "configurations": [</div><div class="line">    &#123;</div><div class="line">      <span class="attr">"type"</span>: <span class="string">"chrome"</span>,</div><div class="line">      <span class="attr">"request"</span>: <span class="string">"launch"</span>,</div><div class="line">      <span class="attr">"name"</span>: <span class="string">"Launch Chrome against localhost"</span>,</div><div class="line">      <span class="attr">"url"</span>: <span class="string">"http://localhost:8080"</span>,</div><div class="line">      // "sourceMaps": true, // 默认为true 不写也行</div><div class="line">      "webRoot": "$&#123;workspaceFolder&#125;"</div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">      <span class="attr">"type"</span>: <span class="string">"chrome"</span>,</div><div class="line">      <span class="attr">"request"</span>: <span class="string">"attach"</span>,</div><div class="line">      <span class="attr">"name"</span>: <span class="string">"Launch Chrome against localhost"</span>,</div><div class="line">      <span class="attr">"port"</span>: <span class="number">9222</span>,</div><div class="line">      <span class="attr">"webRoot"</span>: <span class="string">"$&#123;workspaceFolder&#125;"</span></div><div class="line">    &#125;</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>同时<strong>必须</strong>在webpack.config.js中开启<code>source-map</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">devtool: <span class="string">'source-map'</span>,</div></pre></td></tr></table></figure><p>​</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目标&quot;&gt;&lt;a href=&quot;#目标&quot; class=&quot;headerlink&quot; title=&quot;目标&quot;&gt;&lt;/a&gt;目标&lt;/h2&gt;&lt;p&gt;使用VSCode来调试经过Webpack打包和Babel转义之后的代码。&lt;/p&gt;
&lt;h2 id=&quot;步骤&quot;&gt;&lt;a href=&quot;#步骤&quot; cla
      
    
    </summary>
    
    
      <category term="VSCode" scheme="https://fi3ework.github.io/tags/VSCode/"/>
    
      <category term="Webpack" scheme="https://fi3ework.github.io/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>关于npm随手记录的知识点</title>
    <link href="https://fi3ework.github.io/2018-01-12/npm-notes/"/>
    <id>https://fi3ework.github.io/2018-01-12/npm-notes/</id>
    <published>2018-01-12T04:46:51.000Z</published>
    <updated>2018-01-14T13:39:52.227Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>NPM下的各个文件夹的含义</p><ul><li><code>dist</code>: 用来放UMD版本的文件</li><li><code>lib</code>: 是<code>package.json</code>中的<code>main</code>指向的入口，使用npm就会调用这个文件夹</li><li><code>src</code>: 源码</li></ul><p><code>lib</code>相比<code>src</code>唯一的作用就是使用<code>babel</code>和<code>webpack</code>进行了转码，因为大多数的build过程不会执行<code>babel</code>的转码，所以<code>lib</code>有更好的兼容性。</p><p><a href="https://stackoverflow.com/questions/39553079/difference-between-lib-and-dist-folders-when-packaging-library-using-webpack" target="_blank" rel="external">Difference between lib and dist folders when packaging library using webpack?</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;NPM下的各个文件夹的含义&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;dist&lt;/code&gt;: 用来放UMD版本的文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lib&lt;/code&gt;: 是&lt;code&gt;package.json&lt;/code&gt;中的&lt;code&gt;main&lt;/cod
      
    
    </summary>
    
    
      <category term="npm" scheme="https://fi3ework.github.io/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>to 2017</title>
    <link href="https://fi3ework.github.io/2017-12-31/2017/"/>
    <id>https://fi3ework.github.io/2017-12-31/2017/</id>
    <published>2017-12-31T12:40:07.000Z</published>
    <updated>2018-01-20T17:03:26.274Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写什么年记啊"><a href="#写什么年记啊" class="headerlink" title="写什么年记啊"></a>写什么年记啊</h2><p>前些年的时候，大概是在两年前，有一天突发奇想打算写日记，记录自己每天的感悟，希望自己以后能回顾心路历程，经过一番比较，花了30块在App Store买了One Day，Markdown语法，跨三端，不会被墙，简直完美。大概坚持了5天，我就把自己曾经买了这个应用的事情完全忘记了，留下了平均造价六块钱的五篇电子日记。</p><p>然后我就发现我并不适合做写日记这么勤劳的事情，周记的频度也太高，月记的话倒是可行，不过估计也是会有月记不调。还是写年记吧，一方面是频度足够低，另一方面是人群都处于一种告别过去一年的状态，从众的心态很容易提醒我，又一年过去了，大家都在「别管快乐不快乐还是只是为了发个朋友圈」的告别过去的一年，也一起来吧。</p><p>这是第一篇年记，希望还能有2018的年记，如果没有的话，那说明我的年记与五年一度的大会节奏一致。</p><h2 id="跨年的仪式感更强啊"><a href="#跨年的仪式感更强啊" class="headerlink" title="跨年的仪式感更强啊"></a>跨年的仪式感更强啊</h2><p>相比过年，我觉得跨年的仪式感更强。一方面是因为每年过年的时间是不一样的，这给我一种很随意的感觉，这也是我极度抵制阴历生日的原因。另一方面是过年只是中国才有的节日，但跨年是全世界人民同时的狂欢，准确的说是某时区人民同时的狂欢。不管怎么说，单单从日历上看，跨年也给了我足够的仪式感（而且过年好麻烦啊🙂）。</p><h2 id="写什么前端啊"><a href="#写什么前端啊" class="headerlink" title="写什么前端啊"></a>写什么前端啊</h2><p>从大概二月份开始撸<del>大</del>前端，还不包括没有记录在案的在2016年的国庆节在床上躺着看完了「Head First HTML与CSS、XHTML」的那本书（怀念一下在天国的XHTML），撸html，撸CSS，撸js，撸Nodejs，撸React，撸出了个Hexo的主题，放在了Github上，也算是一直用心在维护，得了一百多个star，算是今年比较值得自己骄傲的事情吧，撸完之后我就感觉<del>（贤者模式）</del>，有些人问前端怎么自学做一些入门项目，其实撸个Hexo(Jekyll)的主题是坠吼的，UI设计+语义化html+响应式设计+css(scss)+dom操作+性能优化+Webpack+gulp+Ajax，高兴的话还可以用mvvm的框架撸，想练什么都可以，做完还能吃自己的狗粮主题再放到Github上骗一波star，这种操作就问你滋补滋磁啊。</p><p>10月份左右用React撸了个<del>高仿的</del>豆瓣电影，一会儿写完年记赶在2018到来前传到Github上，本来一开始撸得兴致盎然，但越撸到后面越恶心，充分证明了小撸怡情，大撸伤身，樯橹灰飞烟灭——各种重复的业务逻辑，然后就开始抽象，重构，抽象，重构，抽公共组件，简化逻辑，为了不让自己放弃，索性把微信签名都换成了「DON’T REPEAT YOURSELF」，可以说是superDRY的一个男子了，截止到2017年的最后一天算是抽完了逻辑，不过多少有些不可维护的感觉，明年看完「深入React技术栈」，再看看能不能撸得更优雅一些吧。</p><p>附一张2017年的Github star的图，我有个习惯就是先在本地提交，整体做的差不多了删掉<code>.git</code><del>（清爽！）</del>。重新开仓库再push到Github上，所以在做<code>hexo-theme-archer</code>的时候少了很多次的提交，不过剩下的这些提交里有好多是blog的提交（逃）</p><p><img src="http://oumn0o088.bkt.clouddn.com/2017-star.jpg" alt="2017-star"></p><h2 id="更不能写C艹啊"><a href="#更不能写C艹啊" class="headerlink" title="更不能写C艹啊"></a>更不能写C艹啊</h2><p>是的，我基本已经不会写C++了，不<del>知道</del>是好事<del>还是坏事</del>，虽然工作中每天对着的都是C++，但是讲道理工作时基本都是在维护一些陈旧的代码（其中也包括自己写的一些操蛋的代码），偶尔也会燃起一点想用更优雅的方式重构一下的热情，但是很快就被我贫乏的C++语法知识浇灭了，老老实实的多些两行注释显得更加实际。</p><h2 id="那他娘的写啥啊"><a href="#那他娘的写啥啊" class="headerlink" title="那他娘的写啥啊"></a>那他娘的写啥啊</h2><p>那当然还是写JavaScript啦，明年也要学Nodejs，还有先把看了N遍还TMD没看明白的<code>redux-saga</code>看懂，也许会再学一点python做做自动化脚本（反正和js差不多），还有shell（shell还用学？），也许有余力会学一点TypeScript（不过见过的TypeScript都是用在企业级大项目上），最后争取开始做可视化方面的东西，目标定太多不好，就先这样。</p><h2 id="人傻多看书啊"><a href="#人傻多看书啊" class="headerlink" title="人傻多看书啊"></a>人傻多看书啊</h2><p>今年还是看了不少书的，</p><ol><li>『<a href="https://www.douban.com/link2/?url=https%3A%2F%2Fbook.douban.com%2Fsubject%2F3040870%2F&amp;query=Head+First+HTML%E4%B8%8ECSS%E3%80%81XHTML&amp;cat_id=1001&amp;type=search&amp;pos=0" target="_blank" rel="external">Head First HTML与CSS、XHTML（中文版）</a>』（明明是去年看完的书被强行拉过来凑数）</li><li>『<a href="https://www.douban.com/link2/?url=https%3A%2F%2Fbook.douban.com%2Fsubject%2F1921890%2F&amp;query=JavaScript+dom%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF&amp;cat_id=1001&amp;type=search&amp;pos=0" target="_blank" rel="external">JavaScript DOM编程艺术</a>』（入门书，忘了讲的是啥了，还不错）</li><li>『<a href="https://www.douban.com/link2/?url=https%3A%2F%2Fbook.douban.com%2Fsubject%2F10546125%2F&amp;query=JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1&amp;cat_id=1001&amp;type=search&amp;pos=1" target="_blank" rel="external">JavaScript高级程序设计（第3版） </a>』（S+级书，每次看都有新发现，期待第四版）</li><li>『<a href="https://www.douban.com/link2/?url=https%3A%2F%2Fbook.douban.com%2Fsubject%2F2208550%2F&amp;query=CSS%E5%AE%9E%E6%88%98%E6%89%8B%E5%86%8C&amp;cat_id=1001&amp;type=search&amp;pos=0" target="_blank" rel="external">CSS实战手册</a>』（从工程角度入门的CSS书，还介绍了圣杯布局什么的，不错）</li><li>『<a href="https://www.douban.com/link2/?url=https%3A%2F%2Fbook.douban.com%2Fsubject%2F1898098%2F&amp;query=%E7%B2%BE%E9%80%9ACSS&amp;cat_id=1001&amp;type=search&amp;pos=0" target="_blank" rel="external">精通CSS</a>』（然而我CSS依旧很渣）</li><li>『<a href="https://www.douban.com/link2/?url=https%3A%2F%2Fbook.douban.com%2Fsubject%2F2228378%2F&amp;query=JavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97&amp;cat_id=1001&amp;type=search&amp;pos=0" target="_blank" rel="external">JavaScript权威指南</a>』（S+级字典书，很吼很强大，有时间一定要仔细看完）</li><li>『<a href="https://www.douban.com/link2/?url=https%3A%2F%2Fbook.douban.com%2Fsubject%2F3590768%2F&amp;query=JavaScript%E8%AF%AD%E8%A8%80%E7%B2%BE%E7%B2%B9&amp;cat_id=1001&amp;type=search&amp;pos=0" target="_blank" rel="external">JavaScript语言精粹</a>』（讲道理，好多东西已经过时了）</li><li>『<a href="https://www.douban.com/link2/?url=https%3A%2F%2Fbook.douban.com%2Fsubject%2F25786138%2F&amp;query=Effective+JavaScript&amp;cat_id=1001&amp;type=search&amp;pos=0" target="_blank" rel="external">Effective JavaScript</a>』（不错，有些东西过时但是依旧有用）</li><li>『<a href="https://www.douban.com/link2/?url=https%3A%2F%2Fbook.douban.com%2Fsubject%2F5362856%2F&amp;query=%E9%AB%98%E6%80%A7%E8%83%BDJavaScript&amp;cat_id=1001&amp;type=search&amp;pos=0" target="_blank" rel="external">高性能JavaScript </a>』（好书，有时间还得再重温一次）</li><li>『<a href="https://www.douban.com/link2/?url=https%3A%2F%2Fbook.douban.com%2Fsubject%2F27106846%2F&amp;query=%E9%AB%98%E6%80%A7%E8%83%BD%E5%93%8D%E5%BA%94%E5%BC%8FWeb%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98&amp;cat_id=1001&amp;type=search&amp;pos=0" target="_blank" rel="external">高性能响应式Web开发实战</a>』（很好的一本书，性能优化加响应式适配）</li><li>『<a href="https://www.douban.com/link2/?url=https%3A%2F%2Fbook.douban.com%2Fsubject%2F27072230%2F&amp;query=%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6&amp;cat_id=1001&amp;type=search&amp;pos=0" target="_blank" rel="external">深入理解ES6</a>』（Zakas大神的书，和阮老师的ES6教程搭配服用效果更好）</li><li>『<a href="https://www.douban.com/link2/?url=https%3A%2F%2Fbook.douban.com%2Fsubject%2F26918038%2F&amp;query=%E6%B7%B1%E5%85%A5React%E6%8A%80%E6%9C%AF%E6%A0%88&amp;cat_id=1001&amp;type=search&amp;pos=0" target="_blank" rel="external">深入React技术栈</a>』（基本是公认的关于React书的巅峰之作，还在看）</li><li>『<a href="https://www.douban.com/link2/?url=https%3A%2F%2Fbook.douban.com%2Fsubject%2F27033213%2F&amp;query=%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAReact%E5%92%8CRedux&amp;cat_id=1001&amp;type=search&amp;pos=0" target="_blank" rel="external">深入浅出React和Redux</a>』（程墨大大的书，讲道理如果上来看上边那书，就是React从入门到放弃了）</li><li>『<a href="https://www.douban.com/link2/?url=https%3A%2F%2Fbook.douban.com%2Fsubject%2F3794471%2F&amp;query=%E9%94%8B%E5%88%A9%E7%9A%84jQuery&amp;cat_id=1001&amp;type=search&amp;pos=0" target="_blank" rel="external">锋利的jQuery</a>』（看了几章没看了，想了一下还是等用深入用jQuery的时候再现看比较好）</li><li>『<a href="https://www.douban.com/link2/?url=https%3A%2F%2Fbook.douban.com%2Fsubject%2F21792530%2F&amp;query=%E7%BC%96%E5%86%99%E5%8F%AF%E7%BB%B4%E6%8A%A4%E7%9A%84JavaScript&amp;cat_id=1001&amp;type=search&amp;pos=0" target="_blank" rel="external">编写可维护的JavaScript</a>』（还在看，很多规矩，manners make man）</li></ol><p>这么看，这一年还是看了不少书，明年再接再厉吧<del>少年</del>中年人。</p><h2 id="实况踢起tika-taka啊"><a href="#实况踢起tika-taka啊" class="headerlink" title="实况踢起tika-taka啊"></a>实况踢起tika-taka啊</h2><p>这一年基本上没怎么玩过游戏，好像是2月份在大家毕业前玩了几把DotA就再也没碰过了，王者荣耀也一点没有想玩的欲望，大部分娱乐的时间都用来玩PES2017了，<del>实况头球</del>2017的引擎总算是能让人踢出正常的tika-taka+直塞了，不过我压根不会用巴萨来开档，斯坦福桥惨案之后坚定的对巴萨粉转黑。</p><p>用皇马玩了两个赛季，用阿森纳玩了半个赛季，买了伊瓜因作主力前锋，头顶脚踢都不在话下，手感一流，偷猎者属性抢点无敌，还能远射大力出奇迹。可惜年纪大了体力经常不够需要有人当替补，就买了卢卡库，成长好，硬又黑，无脑中路给头球。右后卫买了疯狗贝莱林，疯狗般的速度，疯狗般的成长，要是在阿森纳也能有这水准就好了。前腰这个位置在实况里一直吃力不讨好，买了丁丁我也踢不好，后来把丁丁换成右中前卫好了点。中场还有拉姆塞，体力🐶，用起来非常舒服。最让人惊喜的就是托马斯穆勒了，本身我就很喜欢这个球员，用穆勒打虚假跑位的SS，助攻进球抢点什么都能做，体力值还高，开档必买，不过我用阿森纳开档就买了穆勒踢了半个赛季，这哥死活无法续约，心疼小破厂，在游戏里都被欺负（逃）。</p><p>希望明年能踢得更好，期待PES2018。</p><h2 id="看了一些球啊"><a href="#看了一些球啊" class="headerlink" title="看了一些球啊"></a>看了一些球啊</h2><p>这一年比较意外的是看的球还不少，大部分时间都是在<del>听</del>看英超，看完还会去刷刷知乎，看看大神们是从什么角度分析的，某个回答里有一句印象很深刻的话，大概是</p><blockquote><p>『我们仰望梅西，那是神的水准</p><p>​    所以我们会像C罗一样勤奋</p><p>​    但最后，我们会发现和自己最像的，是鲁尼』</p></blockquote><p>明年的🇷🇺世界杯，支持一记🇧🇪。</p><h2 id="2018"><a href="#2018" class="headerlink" title="2018"></a>2018</h2><p>希望，在2018，实现，所有，自己，想要的。</p><p>最后引用「恶毒梁欢秀」里的一句话结尾：</p><blockquote><p> 2017——操你妈。</p><p> 新的一年，让我们更主动一点。</p><p> 2018，在这里提前，操你妈。</p></blockquote><p>来吧，2018。</p><p><br></p><p><br></p><p><br></p><p>对了，</p><p>2017年我还是没有猫，希望2018年能有。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写什么年记啊&quot;&gt;&lt;a href=&quot;#写什么年记啊&quot; class=&quot;headerlink&quot; title=&quot;写什么年记啊&quot;&gt;&lt;/a&gt;写什么年记啊&lt;/h2&gt;&lt;p&gt;前些年的时候，大概是在两年前，有一天突发奇想打算写日记，记录自己每天的感悟，希望自己以后能回顾心路历程，经过
      
    
    </summary>
    
      <category term="生活" scheme="https://fi3ework.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="生活" scheme="https://fi3ework.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>弱渣的常用git命令</title>
    <link href="https://fi3ework.github.io/2017-12-11/git-gist/"/>
    <id>https://fi3ework.github.io/2017-12-11/git-gist/</id>
    <published>2017-12-11T13:23:36.000Z</published>
    <updated>2018-01-21T12:56:41.949Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个基本上只会push和pull的还依赖于SourceTree的git弱渣，随手记录一下自己使用过的git命令，让自己以后找起来更方便🙄</p><ul><li><p><strong>修正最后一个 commit 消息</strong></p><p><strong>场景：</strong>你在最后一条 commit 消息里有个笔误，已经执行了 <code>git commit -m &quot;Fxies bug #42&quot;，但在</code> <code>git push</code> 之前你意识到消息应该是 “Fixes bug #42″。</p><p><strong>方法:</strong> <code>git commit --amend</code> 或 <code>git commit --amend -m &quot;Fixes bug #42&quot;</code></p><p><strong>原理:</strong> <code>git commit --amend</code> 会用一个新的 commit 更新并替换最近的 commit ，这个新的 commit 会把任何修改内容和上一个 commit 的内容结合起来。如果当前没有提出任何修改，这个操作就只会把上次的 commit 消息重写一遍。</p></li><li><p><strong>撤销最后一个commit</strong></p><p><strong>场景：</strong>在完成了一次本地commit之后，对这次commit不是十分满意，想要撤销这条commit记录</p><p><strong>方法：</strong><code>git reset &lt;last good SHA&gt;</code> 或 <code>git reset --hard &lt;last good SHA&gt;</code></p><p><strong>原理：</strong><code>git reset</code> 会把你的代码库历史返回到指定的 SHA 状态。 这样就像是这些提交从来没有发生过。缺省情况下，撤销的commit的修改的代码将会恢复到工作区，对应的commit的记录被撤销掉。如果加了<code>--hard</code>，那么撤销的commit的代码也会消失掉。如果想一并撤销远端的提交，使用<code>git push origin master --force</code>或者<code>git push -f origin master</code>即可，sourceTree里也有开启force push的选项。</p></li></ul><p><strong>参考：</strong><a href="https://stackoverflow.com/questions/10510462/force-git-push-to-overwrite-remote-files" target="_blank" rel="external">Force “git push” to overwrite remote files</a></p><ul><li><p><strong>合并远端新建的的分支</strong></p><ul><li><a href="http://blog.csdn.net/lindexi_gd/article/details/52554159" target="_blank" rel="external">http://blog.csdn.net/lindexi_gd/article/details/52554159</a></li><li><a href="https://stackoverflow.com/questions/37937984/git-refusing-to-merge-unrelated-histories" target="_blank" rel="external">https://stackoverflow.com/questions/37937984/git-refusing-to-merge-unrelated-histories</a></li></ul></li><li><p><strong>合并多次commit</strong></p><p><strong>场景：</strong>将多次提交的commit合并为一次提交。</p><p><strong>方法：</strong></p><ul><li><a href="https://www.jianshu.com/p/964de879904a" target="_blank" rel="external">「Git」合并多个 Commit</a></li><li><a href="https://git-scm.com/book/zh/v1/Git-%E5%B7%A5%E5%85%B7-%E9%87%8D%E5%86%99%E5%8E%86%E5%8F%B2" target="_blank" rel="external">Git 工具 - 重写历史</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作为一个基本上只会push和pull的还依赖于SourceTree的git弱渣，随手记录一下自己使用过的git命令，让自己以后找起来更方便🙄&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;修正最后一个 commit 消息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;
      
    
    </summary>
    
    
      <category term="git" scheme="https://fi3ework.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>React中的HTML转义写法</title>
    <link href="https://fi3ework.github.io/2017-12-05/React%E4%B8%AD%E7%9A%84%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6/"/>
    <id>https://fi3ework.github.io/2017-12-05/React中的转义字符/</id>
    <published>2017-12-05T14:03:32.000Z</published>
    <updated>2017-12-05T15:58:31.378Z</updated>
    
    <content type="html"><![CDATA[<h2 id="在JSX中输出固定内容"><a href="#在JSX中输出固定内容" class="headerlink" title="在JSX中输出固定内容"></a>在JSX中输出固定内容</h2><ol><li><p>直接使用UTF-8字符</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;版权 ©&lt;<span class="regexp">/div&gt;</span></div></pre></td></tr></table></figure></li><li><p>使用HTML转义字符</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;版权 &amp;copy;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></div></pre></td></tr></table></figure><p>或者十进制的转义字符</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;版权 &amp;#169;&lt;/div&gt;</div></pre></td></tr></table></figure></li></ol><h2 id="动态内容的转义"><a href="#动态内容的转义" class="headerlink" title="动态内容的转义"></a>动态内容的转义</h2><p>但是如果在外面加一层大括号的话，react为了防止xss会将转义后的字符实体再次转义</p><blockquote><p>React 会将所有要显示到 DOM 的字符串转义，防止 XSS。所以，如果 JSX 中含有转义后的实体字符，比如 &copy;（©），则最后 DOM 中不会正确显示，因为 React 自动把 &copy; 中的特殊字符转义了。</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;&#123;<span class="string">'版权 &amp;#169;'</span>&#125;&lt;<span class="regexp">/div&gt;</span></div></pre></td></tr></table></figure><p>错误输出</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">版权 &amp;#169;</div></pre></td></tr></table></figure><p>正确写法：</p><ol><li><p>直接使用UTF-8字符仍然可以正确输出</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;&#123;<span class="string">'版权 ©'</span>&#125;&lt;<span class="regexp">/div&gt;</span></div></pre></td></tr></table></figure></li><li><p>安全的做法是使用对应的Unicode码</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;&#123;<span class="string">'版权 \u00a9'</span>&#125;&lt;<span class="regexp">/div&gt;</span></div></pre></td></tr></table></figure></li><li><p>使用<code>fromCharCode</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;&#123;<span class="string">'版权 '</span> + <span class="built_in">String</span>.fromCharCode(<span class="number">169</span>)&#125;&lt;<span class="regexp">/div&gt;</span></div></pre></td></tr></table></figure></li><li><p>使用数组组装</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;&#123;['版权 ', &lt;span&gt;&amp;#169;&lt;/span&gt;]&#125;&lt;/div&gt;</div></pre></td></tr></table></figure></li><li><p>使用<code>dangerouslySetInnerHTML</code>，可以避免React转义字符</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;div dangerouslySetInnerHTML=&#123;&#123; <span class="attr">__html</span>: <span class="string">'版权 &amp;#169;'</span> &#125;&#125; /&gt;</div></pre></td></tr></table></figure></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://shripadk.github.io/react/docs/jsx-gotchas.html#html-entities" target="_blank" rel="external">JSX Gotchas</a></li><li><a href="https://book.douban.com/subject/26918038/" target="_blank" rel="external">深入react技术栈</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;在JSX中输出固定内容&quot;&gt;&lt;a href=&quot;#在JSX中输出固定内容&quot; class=&quot;headerlink&quot; title=&quot;在JSX中输出固定内容&quot;&gt;&lt;/a&gt;在JSX中输出固定内容&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;直接使用UTF-8字符&lt;/p&gt;
&lt;figure c
      
    
    </summary>
    
    
      <category term="React" scheme="https://fi3ework.github.io/tags/React/"/>
    
      <category term="JavaScript" scheme="https://fi3ework.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>为eject后的create-react-app配置ESLint</title>
    <link href="https://fi3ework.github.io/2017-12-03/create-react-app-react-eslint/"/>
    <id>https://fi3ework.github.io/2017-12-03/create-react-app-react-eslint/</id>
    <published>2017-12-03T14:27:28.000Z</published>
    <updated>2017-12-04T06:35:31.086Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>项目一开始使用的是create-react-app创建的，配置的ESLint是用的AlloyTeam的<a href="https://github.com/AlloyTeam/eslint-config-alloy#react" target="_blank" rel="external">eslint-config-alloy/react</a>， 默认配置已经很合理了，并且每条配置都有相应的说明，只需要再根据个人喜好修改一些rule即可，我个人修改的.eslintrc.json配置如下</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"extends"</span>: [</div><div class="line">        <span class="string">"eslint-config-alloy/react"</span></div><div class="line">    ],</div><div class="line">    <span class="attr">"globals"</span>: &#123;</div><div class="line">        // 这里填入你的项目需要的全局变量</div><div class="line">        // 这里值为 false 表示这个全局变量不允许被重新赋值，比如：</div><div class="line">        //</div><div class="line">        // jQuery: false,</div><div class="line">        // $: false</div><div class="line">    &#125;,</div><div class="line">    "rules": &#123;</div><div class="line">        "indent": [</div><div class="line">            "warn",</div><div class="line">            2,</div><div class="line">            &#123;</div><div class="line">                <span class="attr">"SwitchCase"</span>: <span class="number">1</span>,</div><div class="line">                <span class="attr">"flatTernaryExpressions"</span>: <span class="literal">true</span></div><div class="line">            &#125;</div><div class="line">        ],</div><div class="line">        "semi": [</div><div class="line">            "error",</div><div class="line">            <span class="string">"never"</span></div><div class="line">        ],</div><div class="line">        "react/jsx-indent": [</div><div class="line">            "warn",</div><div class="line">            <span class="number">2</span></div><div class="line">        ],</div><div class="line">        "react/jsx-indent-props": [</div><div class="line">            "warn",</div><div class="line">            <span class="number">2</span></div><div class="line">        ],</div><div class="line">        "no-unused-vars": [</div><div class="line">            "warn",</div><div class="line">            &#123;</div><div class="line">                <span class="attr">"vars"</span>: <span class="string">"all"</span>,</div><div class="line">                <span class="attr">"args"</span>: <span class="string">"none"</span>,</div><div class="line">                <span class="attr">"caughtErrors"</span>: <span class="string">"none"</span></div><div class="line">            &#125;</div><div class="line">        ]</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>但是在eject之后运行<code>npm start</code>后会直接报错</p><p><img src="/2017-12-03/create-react-app-react-eslint/./errorSnap.png" alt="errorImg"></p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>按理说，eject前后配置不变，只不过是将配置弹出，npm start 应该可以直接运行，但是却报了ESLint的错误。</p><p>一开始我以为是<a href="https://github.com/AlloyTeam/eslint-config-alloy#react" target="_blank" rel="external">eslint-config-alloy/react</a>的问题，然后重新手写了一些配置依然会报错，证明不是eslint-config-alloy/react的问题。google之后在一个<a href="https://github.com/MoOx/ESLint-loader/issues/168#issuecomment-340350264" target="_blank" rel="external">issue</a>发现：</p><blockquote><p>By default Eslint errors will raise webpack errors unless you change the config as shown above.</p></blockquote><p>也就是说，ESLint的会在发现error级别错误的时候触发webpack报错，导致编译失败。</p><p>但是为什么在eject之前能通过审查的代码在eject后就遇到error报错了呢？</p><p>简单粗暴我们直接看create-react-app<a href="https://github.com/facebookincubator/create-react-app/tree/master/packages/eslint-config-react-app" target="_blank" rel="external">文档</a>中关于ESLint的部分</p><blockquote><p>If you want to enable even more accessibility rules, you can create an <code>.eslintrc</code> file in the root of your project with this content:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt; &#123;</div><div class="line">&gt;   &quot;extends&quot;: [&quot;react-app&quot;, &quot;plugin:jsx-a11y/recommended&quot;],</div><div class="line">&gt;   &quot;plugins&quot;: [&quot;jsx-a11y&quot;]</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>However, if you are using <a href="https://github.com/facebookincubator/create-react-app" target="_blank" rel="external">Create React App</a> and have not ejected, any additional rules will only be displayed in the <a href="https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#displaying-lint-output-in-the-editor" target="_blank" rel="external">IDE integrations</a>, but not in the browser or the terminal.</p></blockquote><p>现在回想一下create-react-app中ESLint是如何工作的，终端有warning/error的信息，但是这个打印出来的信息的其实并不是依照eslint-config-alloy/react规则，而是create-react-app的默认规则。在集成在编辑器（我用的VSCode）中的红色波浪线功能则是根据eslint-config-alloy/react规则显示的。</p><p>但是在eject后，编译与波浪提示都根据eslint-config-alloy/react规则进行代码审查，所以eject前根据默认规则审查通过的代码在eject后并不能通过eslint-config-alloy/react的审查报了错。（eslint-config-alloy/react规则真的很严格）。</p><h3 id="ESLint的error该不该直接退出"><a href="#ESLint的error该不该直接退出" class="headerlink" title="ESLint的error该不该直接退出"></a>ESLint的error该不该直接退出</h3><p>在这里还有一个设计思路与使用思路上的冲突：ESLint默认error级别直接报错退出，是因为将某种rule的错误等级定为error时，当出错代码触发了这个rule，就意味着程序根据规则来说已经不对了，就不需要再往后进行编译等等了。所以代码必须先过了ESLint这关（也就是用户自己对代码定下的规则），才能放到babel里去进行编译。（具体的可以看zakas大神关于这个问题的<a href="https://github.com/ESLint/ESLint/issues/2949" target="_blank" rel="external">讨论</a>）</p><p>（我个人之前本来比较喜欢error时不退出，然后选择性的去修改部分有问题的代码，有些报错的代码就不理会等重构的时候再说。但是仔细一想其实违背了ESLint的思想，既然有warning和error的区分，那些不重要的error其实就应该定义为warning。）</p><h3 id="eslint-loader配置问题"><a href="#eslint-loader配置问题" class="headerlink" title="eslint-loader配置问题"></a>eslint-loader配置问题</h3><p>按照ESLint-loader的<a href="https://github.com/MoOx/ESLint-loader" target="_blank" rel="external">文档</a></p><blockquote><p><code>failOnError</code> (default: <code>false</code>)</p><p>Loader will cause the module build to fail if there are any ESLint errors.</p></blockquote><p><code>failOnError</code>默认是<code>false</code>，按照说明应该是不会阻止build。</p><p>ESLint-loader的作者也<a href="https://github.com/MoOx/ESLint-loader/issues/23#issuecomment-86513306" target="_blank" rel="external">提到</a>（不过远在2015年3月）</p><blockquote><p>failOn* are off by default to avoid webpack to break the build for “just some linting issues”. So you should not have any error/warning that break the build by default.</p></blockquote><p>然而，实际上build依然失败，具体原因我也不清楚，有几个issue也在反应<code>failOnError</code>不起作用，我猜可能是<code>ESLint-loader</code>没能成功的配置<code>ESLint</code>，这个坑以后仔细研究一下再来填（逃。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方案1"><a href="#方案1" class="headerlink" title="方案1"></a>方案1</h3><p>eslint-loader的作者给出的<a href="https://github.com/MoOx/ESLint-loader/issues/23#issuecomment-229417176" target="_blank" rel="external">解决方案</a></p><blockquote><p>Like I said, you can use <code>emitWarning: true</code> option to force all ESLint error/warning being reported as warnings</p></blockquote><p>将<code>emitWarning</code>设为<code>true</code>就可以了，所有的error/warning信息都会打印出来，error也不会阻止编译，简单粗暴。</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">rules: [&#123;</div><div class="line">  enforce: 'pre',</div><div class="line">  test: /\.jsx?$/,</div><div class="line">  loader: 'ESLint-loader',</div><div class="line">  options: &#123;</div><div class="line">    emitWarning: true</div><div class="line">  &#125;</div><div class="line">&#125;]</div></pre></td></tr></table></figure><h3 id="方案2"><a href="#方案2" class="headerlink" title="方案2"></a>方案2</h3><p>遵照zakas大神的设计思路，报error的就阻止编译，改到通过为止，报warning的就打印出来，个人认为这才是正确遵照ESLint的使用方法。</p><h3 id="方案3（粗暴）"><a href="#方案3（粗暴）" class="headerlink" title="方案3（粗暴）"></a>方案3（粗暴）</h3><p>将<code>./node_modules/ESLint-loader/index.js</code>中的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">emitter(webpack.version === <span class="number">2</span> ? <span class="keyword">new</span> ESLintError(messages) : messages)</div></pre></td></tr></table></figure><p>直接注释掉！不给ESLint传递任何错误信息，也不会返回错误码了，这样终端永远都是 0 errors 0 warnings（误），错误就只能通过编辑器的红线提示来看了。</p><h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><blockquote><p>Also to note, the actual <em>build</em> still finishes and produces output. This only affects wrappers that would call webpack, such as <code>webpack-dev-server</code> (won’t automatically reload the browser if lint errors exist) or <code>frontend-maven-plugin</code> (will fail the maven build if lint errors exist).</p></blockquote><p>这位仁兄<a href="https://github.com/MoOx/ESLint-loader/issues/148#issuecomment-280712104" target="_blank" rel="external">提到了</a>关于ESLint其实并不会阻止build，只是会在遇到error时阻止像webpack-dev-server这种服务器对浏览器的自动刷新。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://github.com/MoOx/ESLint-loader/issues/23#issuecomment-343122777" target="_blank" rel="external">errors cause webpack to not build #23</a></li><li><a href="https://github.com/MoOx/ESLint-loader" target="_blank" rel="external">MoOx/ESLint-loader</a></li><li><a href="https://github.com/MoOx/ESLint-loader/issues/168#issuecomment-340350264" target="_blank" rel="external">ESLint error causing Webpack to stop watching/building #168</a></li><li><a href="https://github.com/ESLint/ESLint/issues/2949" target="_blank" rel="external">Option to exit with success even if there are errors #2949</a></li><li><a href="https://github.com/MoOx/ESLint-loader/issues/148" target="_blank" rel="external">ESLint-loader with WebPack 2.2 #148</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;项目一开始使用的是create-react-app创建的，配置的ESLint是用的AlloyTeam的&lt;a href=&quot;https://gi
      
    
    </summary>
    
    
      <category term="React" scheme="https://fi3ework.github.io/tags/React/"/>
    
      <category term="JavaScript" scheme="https://fi3ework.github.io/tags/JavaScript/"/>
    
      <category term="ESLint" scheme="https://fi3ework.github.io/tags/ESLint/"/>
    
  </entry>
  
  <entry>
    <title>基于Decorator的React高阶组件的思路分析与实现</title>
    <link href="https://fi3ework.github.io/2017-11-08/react-HOC/"/>
    <id>https://fi3ework.github.io/2017-11-08/react-HOC/</id>
    <published>2017-11-08T07:14:25.000Z</published>
    <updated>2017-12-12T13:16:10.309Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="https://book.douban.com/subject/26918038/" target="_blank" rel="external">深入react 技术栈</a>一书中，提到了基于Decorator的HOC。而不是直接通过父组件来逐层传递props，因为当业务逻辑越来越复杂的时候，props的传递和维护也将变得困难且冗余。</p><p>书里对基于Decorator的HOC没有给出完整的实现，在这里实现并记录一下实现的思路。</p><p>整个实现的代码放到了<a href="https://github.com/fi3ework/React-decorator-HOC" target="_blank" rel="external">我的Github</a>上，是用来获取豆瓣的电影列表的，<code>npm start</code>即可开箱。</p><h2 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a>整体思路</h2><p><img src="https://pic1.zhimg.com/50/962d2398bbd565e50f0927688f217db8_hd.jpg" alt="img"></p><p>书里描述的整体思路，先将整个组件，按照<strong>view逻辑</strong>抽象为互不重叠的最小的原子组件，使组件间组合更自由。在这里最小的组件就是<code>SearchInput</code> <code>SelectInput</code> <code>List</code>。原子组件一定是<strong>纯粹的、木偶式的组件</strong>，如果他们自身带有复杂的交互/业务逻辑，那么在组合起来以后可想需要修改多少个原子组件，也就失去了相对配置式的优势。</p><h2 id="组件实现"><a href="#组件实现" class="headerlink" title="组件实现"></a>组件实现</h2><h3 id="原子组件"><a href="#原子组件" class="headerlink" title="原子组件"></a>原子组件</h3><p>这是对原书代码稍加修改的SearchInput原子组件，因为没加Icon，所以改了一下（逃），整体思路不变。原子组件没什么可说的，木偶组件就是接收props来实现功能，是对view层逻辑的抽象。</p><p>需要一提的是<code>displayName</code>，是用来确定组件的『身份』的，会被包裹它的组合组件用到，后面会提到组合组件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">SearchInput</span> <span class="keyword">extends</span> <span class="title">PureComponent</span> </span>&#123;</div><div class="line">  <span class="keyword">static</span> displayName = <span class="string">'SearchInput'</span></div><div class="line"></div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">const</span> &#123; onSearch, placeholder &#125; = <span class="keyword">this</span>.props</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;div&gt;</div><div class="line">        &lt;p&gt;SearchSelect&lt;<span class="regexp">/p&gt;</span></div><div class="line"><span class="regexp">        &lt;div&gt;</span></div><div class="line"><span class="regexp">          &lt;Input</span></div><div class="line"><span class="regexp">            type="text"</span></div><div class="line"><span class="regexp">            placeholder=&#123;placeholder&#125;</span></div><div class="line"><span class="regexp">            onChange=&#123;onSearch&#125;</span></div><div class="line"><span class="regexp">          /</span>&gt;</div><div class="line">        &lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">      &lt;/</span>div&gt;</div><div class="line">    )</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Decorator组件"><a href="#Decorator组件" class="headerlink" title="Decorator组件"></a>Decorator组件</h3><p>先放代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> searchDecorator = <span class="function"><span class="params">WrappedComponent</span> =&gt;</span> &#123;</div><div class="line">  <span class="class"><span class="keyword">class</span> <span class="title">SearchDecorator</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(props) &#123;</div><div class="line">      <span class="keyword">super</span>(props)</div><div class="line">      <span class="keyword">this</span>.handleSearch = <span class="keyword">this</span>.handleSearch.bind(<span class="keyword">this</span>)</div><div class="line">      <span class="keyword">this</span>.state = &#123;</div><div class="line">        keyword: <span class="string">''</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    handleSearch(e) &#123;</div><div class="line">      <span class="keyword">this</span>.setState(&#123;</div><div class="line">        keyword: e.target.value</div><div class="line">      &#125;)</div><div class="line">      <span class="keyword">this</span>.props.onSearch(e)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    render() &#123;</div><div class="line">      <span class="keyword">const</span> &#123; keyword &#125; = <span class="keyword">this</span>.state</div><div class="line"></div><div class="line">      <span class="keyword">return</span> (</div><div class="line">        &lt;WrappedComponent</div><div class="line">          &#123;...this.props&#125;</div><div class="line">          data=&#123;<span class="keyword">this</span>.props.data&#125;</div><div class="line">          keyword=&#123;keyword&#125;</div><div class="line">          onSearch=&#123;<span class="keyword">this</span>.handleSearch&#125;</div><div class="line">        /&gt;</div><div class="line">      )</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure><p>Decorator的作用就是将业务/交互逻辑抽象出来进行了处理，view的逻辑还是交由原子组件来实现，可以看到最后的<code>render</code>渲染的还是<code>wrappedComponent</code>，只不过是在经过Decorator之后多了几个props，这些props的中有钩子函数，有要传递给原子组件的参数。</p><p>这样，视图逻辑就由view层抽象，交互/业务逻辑由Decorator来抽象。</p><h2 id="组合组件"><a href="#组合组件" class="headerlink" title="组合组件"></a>组合组件</h2><p>先上代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Selector</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;div&gt;</div><div class="line">        &#123;</div><div class="line">          <span class="keyword">this</span>.props.children.map(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</div><div class="line">            <span class="comment">// SelectInput</span></div><div class="line">            <span class="keyword">if</span> (item.type.displayName === <span class="string">'SelectInput'</span>) &#123;</div><div class="line">              ...</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// SearchInput</span></div><div class="line">            <span class="keyword">if</span> (item.type.displayName === <span class="string">'SearchInput'</span>) &#123;</div><div class="line">              <span class="keyword">return</span> React.cloneElement(item,</div><div class="line">                &#123;</div><div class="line">                  key: <span class="string">'searchInput'</span>,</div><div class="line">                  onSearch: <span class="keyword">this</span>.props.onSearch,</div><div class="line">                  placeholder: <span class="keyword">this</span>.props.searchPlaceholder</div><div class="line">                &#125;</div><div class="line">              )</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// List</span></div><div class="line">            <span class="keyword">if</span> (item.type.displayName === <span class="string">'List'</span>) &#123;</div><div class="line">              ...</div><div class="line">          &#125;)</div><div class="line">        &#125;</div><div class="line">      &lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">    )</span></div><div class="line"><span class="regexp">  &#125;</span></div><div class="line"><span class="regexp">&#125;</span></div></pre></td></tr></table></figure><p>组合组件的children为根据不同业务需要包裹起来的原子组件，组合组件的逻辑处理功能来自于Decorator，各种Decorator的钩子函数或者参数作为props传递给了Selector，Selector再用它们去完成原子组件之间的交互。组合组件通过之前提到的<code>displayName</code>为不同的原子组件分配props并根据业务需要进行组件间逻辑交互的调整。</p><blockquote><p>一个 Decorator 只做最简单的逻辑，只是给组件增加一个原子的智能特性。业务组件通过组织和拼接 Decorator 来实现功能，而不是改变 Decorator 本身的逻辑。</p></blockquote><p>当我们业务逻辑变得复杂的时候，不要去增加Decorator的复杂度，而是去拼接多个Decorator再通过组合组件去处理具体的业务逻辑，这样能保证Decorator的可复用性。</p><h2 id="业务组件"><a href="#业务组件" class="headerlink" title="业务组件"></a>业务组件</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> FinalSelector = compose(asyncSelectDecorator, selectedItemDecorator, searchDecorator)(Selector)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SearchSelect</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;FinalSelector &#123;...this.props&#125;&gt;</div><div class="line">        &lt;SelectInput /&gt;</div><div class="line">        &lt;SearchInput /&gt;</div><div class="line">        &lt;List /&gt;</div><div class="line">      &lt;<span class="regexp">/FinalSelector&gt;</span></div><div class="line"><span class="regexp">    )</span></div><div class="line"><span class="regexp">  &#125;</span></div><div class="line"><span class="regexp">&#125;</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">class App extends Component &#123;</span></div><div class="line"><span class="regexp">  render() &#123;</span></div><div class="line"><span class="regexp">    return (</span></div><div class="line"><span class="regexp">      &lt;SearchSelect</span></div><div class="line"><span class="regexp">        searchPlaceholder=&#123;'请搜索电影'&#125;</span></div><div class="line"><span class="regexp">        onSearch=&#123;(e) =&gt; &#123; console.log(`自定义onSearch: $&#123;e.target.value&#125;`) &#125;&#125;</span></div><div class="line"><span class="regexp">        onClick=&#123;(text) =&gt; &#123; console.log(`自定义onClick: $&#123;text&#125;`) &#125;&#125;</span></div><div class="line"><span class="regexp">        url="/</span>v2/movie/in_theaters<span class="string">"</span></div><div class="line"><span class="string">      /&gt;</span></div><div class="line"><span class="string">    )</span></div><div class="line"><span class="string">  &#125;</span></div><div class="line"><span class="string">&#125;</span></div></pre></td></tr></table></figure><p>通过<code>compose</code>赋予组合组件不同的逻辑处理功能，然后根据业务需要让<code>compose</code>后的组合组件包含原子组件，最后给从最外层传递参数就完成了。</p><h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><p>在实际的场景中也不能滥用HOC，基于Decorator的HOC一般是用来处理偏数据逻辑的部分，而DOM相关的东西就直接简单粗暴的用父组件就好了。</p><blockquote><p>对比 HOC 范式 <strong>compose(render)(state) </strong>与父组件（Parent Component）的范式 <strong>render(render(state))</strong>，如果完全利用 HOC 来实现 React 的 implement，将操作与 view 分离，也未尝不可，但却不优雅。HOC 本质上是统一功能抽象，强调逻辑与 UI 分离。但在实际开发中，前端无法逃离 DOM ，而逻辑与 DOM 的相关性主要呈现 3 种关联形式：</p><ul><li>与 DOM 相关，建议使用父组件，类似于原生 HTML 编写</li><li>与 DOM 不相关，如校验、权限、请求发送、数据转换这类，通过数据变化间接控制 DOM，可以使用 HOC 抽象</li><li>交叉的部分，DOM 相关，但可以做到完全内聚，即这些 DOM 不会和外部有关联，均可</li></ul></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://book.douban.com/subject/26918038/" target="_blank" rel="external">深入react 技术栈</a></li><li><a href="https://zhuanlan.zhihu.com/p/22054582" target="_blank" rel="external">基于Decorator的组件扩展实践</a></li><li><a href="https://zhuanlan.zhihu.com/p/27434557" target="_blank" rel="external">精读 React 高阶组件</a></li><li><a href="https://zhuanlan.zhihu.com/p/24776678" target="_blank" rel="external">深入理解 React 高阶组件</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在&lt;a href=&quot;https://book.douban.com/subject/26918038/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;深入react 技术栈&lt;/a&gt;一书中，提到了基于Decorator的HOC。而不是直接通过父组件来逐层传递
      
    
    </summary>
    
    
      <category term="React" scheme="https://fi3ework.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>简明React Router v4教程</title>
    <link href="https://fi3ework.github.io/2017-10-28/A%20Simple%20React%20Router%20v4%20Tutorial/"/>
    <id>https://fi3ework.github.io/2017-10-28/A Simple React Router v4 Tutorial/</id>
    <published>2017-10-28T15:22:41.000Z</published>
    <updated>2018-01-14T14:45:53.965Z</updated>
    
    <content type="html"><![CDATA[<p>翻译自<a href="https://medium.com/@pshrmn/a-simple-react-router-v4-tutorial-7f23ff27adf" target="_blank" rel="external">A Simple React Router v4 Tutorial</a></p><h1 id="简明React-Router-v4教程"><a href="#简明React-Router-v4教程" class="headerlink" title="简明React Router v4教程"></a>简明React Router v4教程</h1><p>React Router v4是一个完全使用React重写的流行的React包，之前版本的React Router配置是使用伪组件也很晦涩难懂。现在使用v4版本的React Router，所有的东西都“仅仅是组件”。</p><p>在这个教程中，我们将建立一个本地的运动队，我们将完成所有的基本需求来建立我们的网站和路由，这包括：</p><ol><li>选择<code>router</code></li><li>创建<code>routes</code></li><li>在路由之间通过链接进行导航</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://codesandbox.io/s/vVoQVk78" target="_blank" rel="external"><img src="https://codesandbox.io/static/img/play-codesandbox.svg" alt="Edit A Simple React Router v4 Tutorial"></a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>React Router现在已经被划分成了三个包：<code>react-router</code>，<code>react-router-dom</code>，<code>react-router-native</code>。</p><p>你不应该直接安装<code>react-router</code>，这个包为React Router应用提供了核心的路由组件和函数，另外两个包提供了特定环境的组件（浏览器和<code>react-native</code>对应的平台），不过他们也将<code>react-router</code>导出的功能再次导出。</p><p>你应该选择这两个中适应你开发环境的包，我们需要构建一个网站（在浏览器中运行），所以我们要安装<code>react-router-dom</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --save react-router-dom</div></pre></td></tr></table></figure><h2 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h2><p>当开始一个新项目时，你应该决定要使用哪种<code>router</code>。对于在浏览器中运行的项目，我们可以选择<code>&lt;BrowserRouter</code>和<code>&lt;HashRouter&gt;</code>组件，<code>&lt;BrowserRouter&gt;</code>应该用在服务器处理动态请求的项目中（知道如何处理任意的URI），<code>&lt;HashRouter&gt;</code>用来处理静态页面（只能响应请求已知文件的请求）。</p><p>通常来说更推荐使用<code>&lt;BrowserRouter&gt;</code>，可是如果服务器只处理静态页面的请求，那么使用<code>&lt;HashRouter&gt;</code>也是一个足够的解决方案。</p><p>对于我们的项目，我们假设所有的页面都是由服务器动态生成的，所以我们的<code>router</code>组件选择<code>&lt;BrowserRouter&gt;</code>。</p><h3 id="History"><a href="#History" class="headerlink" title="History"></a>History</h3><p>每个<code>router</code>都会创建一个<code>history</code>对象，用来保持对当前位置的追踪还有在页面发生变化的时候重新渲染页面。React Router提供的其他组件依赖在<code>context</code>上储存的<code>history</code>对象，所以他们必须在<code>router</code>对象的内部渲染。<strong>一个没有<code>router</code>祖先元素的React Router对象将无法正常工作</strong>，如果你想学习更多的关于<code>history</code>对象的知识，可以参照<a href="https://medium.com/@pshrmn/a-little-bit-of-history-f245306f48dd" target="_blank" rel="external">这篇文章</a>。</p><h3 id="渲染一个-lt-Router-gt"><a href="#渲染一个-lt-Router-gt" class="headerlink" title="渲染一个&lt;Router&gt;"></a>渲染一个<code>&lt;Router&gt;</code></h3><p>Router的组件只能接受一个子元素，为了遵照这种限制，创建一个<code>&lt;App&gt;</code>组件来渲染其他的应用将非常方便（将应用从router中分离对服务器端渲染也有重要意义，因为我们在服务器端转换到<code>&lt;MemoryRouter&gt;</code>时可以很快复用<code>&lt;App&gt;</code>）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; BrowserRouter &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span></div><div class="line">ReactDOM.render((</div><div class="line">  &lt;BrowserRouter&gt;</div><div class="line">    &lt;App /&gt;</div><div class="line">  &lt;<span class="regexp">/BrowserRouter&gt;</span></div><div class="line"><span class="regexp">), document.getElementById('root'))</span></div></pre></td></tr></table></figure><p>现在我们已经选择了router，我们可以开始渲染我们真正的应用了。</p><h2 id="lt-App-gt"><a href="#lt-App-gt" class="headerlink" title="&lt;App&gt;"></a><code>&lt;App&gt;</code></h2><p>我们的应用定义在<code>&lt;App&gt;</code>组件中，为了简化<code>&lt;App&gt;</code>，我们将我们的应用分为两个部分，<code>&lt;Header&gt;</code>组件包含链接到其他页面的导航，<code>&lt;Main&gt;</code>组件包含其余的需要渲染的部分。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// this component will be rendered by our &lt;___Router&gt;</span></div><div class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> (</div><div class="line">  &lt;div&gt;</div><div class="line">    &lt;Header /&gt;</div><div class="line">    &lt;Main /&gt;</div><div class="line">  &lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">)</span></div></pre></td></tr></table></figure><p><strong>Note:</strong> 你可以任意布局你的应用，分离routes和导航让你更加容易了解React Router是如何工作的。</p><p>我们先从渲染我们路由内容的<code>&lt;Main&gt;</code>组件开始。</p><h2 id="Routes"><a href="#Routes" class="headerlink" title="Routes"></a>Routes</h2><p><code>&lt;Route&gt;</code>组件是React Router的主要组成部分，如果你想要在路径符合的时候在任何地方渲染什么东西，你就应该创造一个<code>&lt;Route&gt;</code>元素。</p><h3 id="Path"><a href="#Path" class="headerlink" title="Path"></a>Path</h3><p>一个<code>&lt;Route&gt;</code>组件需要一个string类型的<code>path</code>prop来指定路由需要匹配的路径。举例来说<code>&lt;Route path=&#39;/roster/&#39;</code>将匹配以<code>/roster</code>开始的路径，当当前的路径和<code>path</code>匹配时，route将会渲染React的元素。当路径不匹配的时候 ，路由不会渲染任何元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;Route path=<span class="string">'/roster'</span>/&gt;</div><div class="line"><span class="comment">// when the pathname is '/', the path does not match</span></div><div class="line"><span class="comment">// when the pathname is '/roster' or '/roster/2', the path matches</span></div><div class="line"><span class="comment">// If you only want to match '/roster', then you need to use</span></div><div class="line"><span class="comment">// the "exact" prop. The following will match '/roster', but not</span></div><div class="line"><span class="comment">// '/roster/2'.</span></div><div class="line">&lt;Route exact path=<span class="string">'/roster'</span>/&gt;</div><div class="line"><span class="comment">// You might find yourself adding the exact prop to most routes.</span></div><div class="line"><span class="comment">// In the future (i.e. v5), the exac t prop will likely be true by</span></div><div class="line"><span class="comment">// default. For more information on that, you can check out this </span></div><div class="line"><span class="comment">// GitHub issue:</span></div><div class="line"><span class="comment">// https://github.com/ReactTraining/react-router/issues/4958</span></div></pre></td></tr></table></figure><p><strong>Note: </strong>在匹配路由的时候，React Router只会关心相对路径的部分，所以如下的URL</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://www.example.com/my-projects/one?extra=false</div></pre></td></tr></table></figure><p>React Router只会尝试匹配<code>/my-projects/one</code>部分。</p><h3 id="匹配路径"><a href="#匹配路径" class="headerlink" title="匹配路径"></a>匹配路径</h3><p>React Router使用<code>path-to-regexp</code>包来判断路径的<code>path</code>prop是否匹配当前路径，它将<code>path</code>字符串转换成正则表达式与当前的路径进行匹配，关于<code>path</code>字符串更多的可选格式，可以查阅<a href="https://github.com/pillarjs/path-to-regexp" target="_blank" rel="external"><code>path-to-regexp</code>文档</a>。</p><p>当路由与路径匹配的时候，一个具有以下<code>match</code>对象将会被作为prop传入</p><ul><li><code>url</code> - 当前路径与路由相匹配的部分</li><li><code>path</code> - 路由的<code>path</code></li><li><code>isExact</code> - <code>path === pathname</code></li><li><code>params</code> - 一个包含着<code>pathname</code>的对象</li></ul><p><strong>Note: </strong>目前，路由的路径必须是绝对路径。</p><h3 id="创建我们自己的路由"><a href="#创建我们自己的路由" class="headerlink" title="创建我们自己的路由"></a>创建我们自己的路由</h3><p><code>&lt;Route&gt;</code>s 可以在router中的任意位置被创建，不过一般来说将他们放到同一个地方渲染更加合理，你可以使用<code>&lt;Switch&gt;</code>组件来组合<code>&lt;Route&gt;</code>s，<code>&lt;Switch&gt;</code>将遍历<code>children</code>（路由），然后只匹配第一个符合的<code>pathname</code>。</p><p>对于我们的网站来说，我们想要匹配的路径为：</p><ol><li><code>/</code> - 主页</li><li><code>/roster</code> - 队伍名单</li><li><code>/roster/:number</code> - 队员的资料，number为队员的号码</li><li><code>/schedule</code> - 队伍的赛程表</li></ol><p>为了匹配路径，我们需要创建带<code>path</code>prop的<code>&lt;Route&gt;</code>元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;Switch&gt;</div><div class="line">  &lt;Route exact path=<span class="string">'/'</span> component=&#123;Home&#125;/&gt;</div><div class="line">  &#123;<span class="comment">/* both /roster and /roster/:number begin with /roster */</span>&#125;</div><div class="line">  &lt;Route path=<span class="string">'/roster'</span> component=&#123;Roster&#125;/&gt;</div><div class="line">  &lt;Route path=<span class="string">'/schedule'</span> component=&#123;Schedule&#125;/&gt;</div><div class="line">&lt;<span class="regexp">/Switch&gt;</span></div></pre></td></tr></table></figure><h3 id="lt-Route-gt-将会渲染什么"><a href="#lt-Route-gt-将会渲染什么" class="headerlink" title="&lt;Route&gt;将会渲染什么"></a><code>&lt;Route&gt;</code>将会渲染什么</h3><p>Routes可以接受三种prop来决定路径匹配时渲染的元素，只能给<code>&lt;Route&gt;</code>元素提供一种来定义要渲染的元素。</p><ol><li><code>&lt;component&gt;</code> - 一个React组件，当一个带有<code>component</code>prop的路由匹配的时候，路由将会返回prop提供的component类型的组件（通过<code>React.createElement</code>渲染）。</li><li><code>render</code> - 一个返回React元素的方法，与<code>component</code>类似，也是当路径匹配的时候会被调用。写成内联形式渲染和传递参数的时候非常方便。</li><li><code>children</code> - 一个返回React元素的方法。与前两种不同的是，这种方法<strong>总是</strong>会被渲染，无论路由与当前的路径是否匹配。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;Route path=<span class="string">'/page'</span> component=&#123;Page&#125; /&gt;</div><div class="line"><span class="keyword">const</span> extraProps = &#123; <span class="attr">color</span>: <span class="string">'red'</span> &#125;</div><div class="line">&lt;Route path=<span class="string">'/page'</span> render=&#123;(props) =&gt; (</div><div class="line">  &lt;Page &#123;...props&#125; data=&#123;extraProps&#125;/&gt;</div><div class="line">)&#125;/&gt;</div><div class="line">&lt;Route path=<span class="string">'/page'</span> children=&#123;(props) =&gt; (</div><div class="line">  props.match</div><div class="line">    ? &lt;Page &#123;...props&#125;/&gt;</div><div class="line">    : &lt;EmptyPage &#123;...props&#125;/&gt;</div><div class="line">)&#125;/&gt;</div></pre></td></tr></table></figure><p>一般来说，我们一般使用<code>component</code>或者<code>render</code>，<code>children</code>的使用场景不多，而且一般来说当路由不匹配的时候最好不要渲染任何东西。在我们的例子中，不需要向路由传递任何参数，所有我们使用<code>&lt;component&gt;</code>。</p><p>由<code>&lt;Route&gt;</code>渲染的元素将会带有一系列的props，有<code>match</code>对象，当前的<code>location</code>对象，还有<code>history</code>对象（由router创建）。</p><h3 id="lt-Main-gt"><a href="#lt-Main-gt" class="headerlink" title="&lt;Main&gt;"></a><code>&lt;Main&gt;</code></h3><p>现在我们已经确定了route的结构，我们只需要将他们实现即可。在我们的应用中，我们将会在<code>&lt;Main&gt;</code>组件中渲染<code>&lt;Switch&gt;</code>和<code>&lt;Route&gt;</code>，它们将会在<code>&lt;main&gt;</code>中渲染HTML元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; Switch, Route &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span></div><div class="line"><span class="keyword">const</span> Main = <span class="function"><span class="params">()</span> =&gt;</span> (</div><div class="line">  &lt;main&gt;</div><div class="line">    &lt;Switch&gt;</div><div class="line">      &lt;Route exact path=<span class="string">'/'</span> component=&#123;Home&#125;/&gt;</div><div class="line">      &lt;Route path=<span class="string">'/roster'</span> component=&#123;Roster&#125;/&gt;</div><div class="line">      &lt;Route path=<span class="string">'/schedule'</span> component=&#123;Schedule&#125;/&gt;</div><div class="line">    &lt;<span class="regexp">/Switch&gt;</span></div><div class="line"><span class="regexp">  &lt;/m</span>ain&gt;</div><div class="line">)</div></pre></td></tr></table></figure><p><strong>Note: </strong>主页的路由带有<code>exact</code>prop，这表明只有完全匹配pathname的时候才会匹配主页。</p><h3 id="路由的嵌套"><a href="#路由的嵌套" class="headerlink" title="路由的嵌套"></a>路由的嵌套</h3><p>队员资料页的路由<code>/roster/:number</code>没有包含在<code>&lt;Switch&gt;</code>中，而是在<code>&lt;Roster&gt;</code>组件中，只要pathname由<code>/roster</code>开头，都将由<code>&lt;Roster&gt;</code>进行渲染。</p><p>在<code>&lt;Roster&gt;</code>组件中我们将渲染两种路径：</p><ol><li><code>/roster</code> - 只有当路径完全匹配<code>/roster</code>时会被渲染，我们要对该路径指定<code>exact</code>参数。</li><li><code>/roster/:number</code> - 这个路由使用一个路径参数来捕获<code>/roster</code>后面带的pathname的部分。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> Roster = <span class="function"><span class="params">()</span> =&gt;</span> (</div><div class="line">  &lt;Switch&gt;</div><div class="line">    &lt;Route exact path=<span class="string">'/roster'</span> component=&#123;FullRoster&#125;/&gt;</div><div class="line">    &lt;Route path=<span class="string">'/roster/:number'</span> component=&#123;Player&#125;/&gt;</div><div class="line">  &lt;<span class="regexp">/Switch&gt;</span></div><div class="line"><span class="regexp">)</span></div></pre></td></tr></table></figure><p>将带有相同前缀的路由放在同一个组件中很方便，这样可以简化父组件并且让我们可以让我们在一个地方渲染所有带有相同前缀的组件。</p><p>举个例子，<code>&lt;Roster&gt;</code>可以为所有以<code>/roster</code>开头的路由渲染一个标题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> Roster = <span class="function"><span class="params">()</span> =&gt;</span> (</div><div class="line">  &lt;div&gt;</div><div class="line">    &lt;h2&gt;This is a roster page!&lt;/h2&gt;</div><div class="line">    &lt;Switch&gt;</div><div class="line">      &lt;Route exact path=<span class="string">'/roster'</span> component=&#123;FullRoster&#125;/&gt;</div><div class="line">      &lt;Route path=<span class="string">'/roster/:number'</span> component=&#123;Player&#125;/&gt;</div><div class="line">    &lt;<span class="regexp">/Switch&gt;</span></div><div class="line"><span class="regexp">  &lt;/</span>div&gt;</div><div class="line">)</div></pre></td></tr></table></figure><h3 id="Path参数"><a href="#Path参数" class="headerlink" title="Path参数"></a>Path参数</h3><p>有的时候我们想捕捉pathname中的多个参数，举例来说，在我们的球员资料路由中，我们通过添加了<code>path</code>参数来捕获了球员的号码。</p><p><code>:number</code>部分代表在pathname中<code>/roster/</code>后面的内容将会被储存在<code>match.params.number</code>。举例来说，一个为<code>/roster/6</code>的pathname将会生成一个如下的params对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123; <span class="attr">number</span>: <span class="string">'6'</span> &#125; <span class="comment">// note that the captured value is a string</span></div></pre></td></tr></table></figure><p><code>&lt;Player&gt;</code>组件使用<code>props.match.params</code>对象来决定应该渲染哪个球员的资料。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// an API that returns a player object</span></div><div class="line"><span class="keyword">import</span> PlayerAPI <span class="keyword">from</span> <span class="string">'./PlayerAPI'</span></div><div class="line"><span class="keyword">const</span> Player = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">const</span> player = PlayerAPI.get(</div><div class="line">    <span class="built_in">parseInt</span>(props.match.params.number, <span class="number">10</span>)</div><div class="line">  )</div><div class="line">  <span class="keyword">if</span> (!player) &#123;</div><div class="line">    <span class="keyword">return</span> &lt;div&gt;Sorry, but the player was not found&lt;/div&gt;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> (</div><div class="line">    &lt;div&gt;</div><div class="line">      &lt;h1&gt;&#123;player.name&#125; (#&#123;player.number&#125;)&lt;/h1&gt;</div><div class="line">      &lt;h2&gt;&#123;player.position&#125;&lt;<span class="regexp">/h2&gt;</span></div><div class="line"><span class="regexp">    &lt;/</span>div&gt;</div><div class="line">)</div></pre></td></tr></table></figure><p>关于<code>path</code>参数可以查阅<a href="https://github.com/pillarjs/path-to-regexp" target="_blank" rel="external"><code>path-to-regexp</code>文档</a>。</p><p>在<code>&lt;Player&gt;</code>组件旁，还有一个<code>&lt;FullRoster&gt;</code>，<code>&lt;Schedule&gt;</code>和<code>&lt;Home&gt;</code>组件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> FullRoster = <span class="function"><span class="params">()</span> =&gt;</span> (</div><div class="line">  &lt;div&gt;</div><div class="line">    &lt;ul&gt;</div><div class="line">      &#123;</div><div class="line">        PlayerAPI.all().map(<span class="function"><span class="params">p</span> =&gt;</span> (</div><div class="line">          &lt;li key=&#123;p.number&#125;&gt;</div><div class="line">            &lt;Link to=&#123;<span class="string">`/roster/<span class="subst">$&#123;p.number&#125;</span>`</span>&#125;&gt;&#123;p.name&#125;&lt;<span class="regexp">/Link&gt;</span></div><div class="line"><span class="regexp">          &lt;/</span>li&gt;</div><div class="line">        ))</div><div class="line">      &#125;</div><div class="line">    &lt;<span class="regexp">/ul&gt;</span></div><div class="line"><span class="regexp">  &lt;/</span>div&gt;</div><div class="line">)</div><div class="line"><span class="keyword">const</span> Schedule = <span class="function"><span class="params">()</span> =&gt;</span> (</div><div class="line">  &lt;div&gt;</div><div class="line">    &lt;ul&gt;</div><div class="line">      &lt;li&gt;<span class="number">6</span>/<span class="number">5</span> @ Evergreens&lt;<span class="regexp">/li&gt;</span></div><div class="line"><span class="regexp">      &lt;li&gt;6/</span><span class="number">8</span> vs Kickers&lt;<span class="regexp">/li&gt;</span></div><div class="line"><span class="regexp">      &lt;li&gt;6/</span><span class="number">14</span> @ United&lt;<span class="regexp">/li&gt;</span></div><div class="line"><span class="regexp">    &lt;/u</span>l&gt;</div><div class="line">  &lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">)</span></div><div class="line"><span class="regexp">const Home = () =&gt; (</span></div><div class="line"><span class="regexp">  &lt;div&gt;</span></div><div class="line"><span class="regexp">    &lt;h1&gt;Welcome to the Tornadoes Website!&lt;/</span>h1&gt;</div><div class="line">  &lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">)</span></div></pre></td></tr></table></figure><h3 id="Links"><a href="#Links" class="headerlink" title="Links"></a>Links</h3><p>最后，我们的网站需要在页面之间导航，如果我们使用<code>&lt;a</code>标签导航的话，将会载入一整个新的页面。React Router提供了一个<code>&lt;Link&gt;</code>组件来阻止其发生，当点击<code>&lt;Link&gt;</code> 时，URL将会更新，页面也会在不载入整个新页面的情况下渲染内容。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; Link &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span></div><div class="line"><span class="keyword">const</span> Header = <span class="function"><span class="params">()</span> =&gt;</span> (</div><div class="line">  &lt;header&gt;</div><div class="line">    &lt;nav&gt;</div><div class="line">      &lt;ul&gt;</div><div class="line">        &lt;li&gt;&lt;Link to='/'&gt;Home&lt;/Link&gt;&lt;/li&gt;</div><div class="line">        &lt;li&gt;&lt;Link to='/roster'&gt;Roster&lt;/Link&gt;&lt;/li&gt;</div><div class="line">        &lt;li&gt;&lt;Link to='/schedule'&gt;Schedule&lt;/Link&gt;&lt;/li&gt;</div><div class="line">      &lt;<span class="regexp">/ul&gt;</span></div><div class="line"><span class="regexp">    &lt;/</span>nav&gt;</div><div class="line">  &lt;<span class="regexp">/header&gt;</span></div><div class="line"><span class="regexp">)</span></div></pre></td></tr></table></figure><p><code>&lt;Link&gt;</code>s使用<code>to</code> prop来决定导航的目标，可以是一个字符串，或者是一个location对象（包含<code>pathname</code>, <code>search</code>, <code>hash</code>和<code>state</code>属性）。当只是一个字符串的时候，将会被转化为一个location对象</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;Link to=&#123;&#123; pathname: '/roster/7' &#125;&#125;&gt;Player #7&lt;/Link&gt;</div></pre></td></tr></table></figure><p><strong>Note: </strong>目前，链接的pathname必须是绝对路径。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>两个在线的例子：</p><ol><li><a href="https://codesandbox.io/s/vVoQVk78" target="_blank" rel="external">CodeSandbox</a></li><li><a href="http://codepen.io/pshrmn/pen/YZXZqM" target="_blank" rel="external">CodePen</a>.</li></ol><h2 id="Notes！"><a href="#Notes！" class="headerlink" title="Notes！"></a>Notes！</h2><p>[1] locations是包含描述URL不同部分的参数的对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// a basic location object</span></div><div class="line">&#123; <span class="attr">pathname</span>: <span class="string">'/'</span>, <span class="attr">search</span>: <span class="string">''</span>, <span class="attr">hash</span>: <span class="string">''</span>, <span class="attr">key</span>: <span class="string">'abc123'</span> state: &#123;&#125; &#125;</div></pre></td></tr></table></figure><p>[2] 可以一个无路径的<code>&lt;Route&gt;</code>，这个路由将会匹配所有路径，这样可以很方便的访问存储在<code>context</code>上的对象和方法。</p><p>[3] 当使用<code>children</code> prop时，即使在路径不匹配的时候也会渲染。</p><p>[4] 相对的<code>&lt;Link&gt;</code>s更加复杂，他们因为可能需要父组件的<code>match</code>对象，而不是当前的URL。</p><p>[5] 这是个基本的无状态组件，<code>component</code>和<code>render</code>的区别是，<code>component</code>会使用<code>React.createElement</code>来创建一个元素，<code>render</code>使用函数来生成组件，如果你想创建一个需要传递prop的组件，那么<code>render</code>会比<code>component</code>来的方便。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;Route path=<span class="string">'/one'</span> component=&#123;One&#125;/&gt;</div><div class="line"><span class="comment">// React.createElement(props.component)</span></div><div class="line">&lt;Route path=<span class="string">'/two'</span> render=&#123;() =&gt; &lt;Two /&gt;&#125;/&gt;</div><div class="line">// props.render()</div></pre></td></tr></table></figure><p>[6] <code>&lt;Route&gt;</code>和<code>&lt;Switch&gt;</code>组件都可以接受一个<code>location</code> prop，这可以让他们被一个不同的location匹配到，而不仅仅是他们实际的location（当前的URL）</p><p>[7] <code>react-router</code>也可以传递<code>staticContext</code>这个prop，但是只在使用服务端渲染的时候有效。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;翻译自&lt;a href=&quot;https://medium.com/@pshrmn/a-simple-react-router-v4-tutorial-7f23ff27adf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;A Simple React Route
      
    
    </summary>
    
    
      <category term="React" scheme="https://fi3ework.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>Redux的工作流程教程</title>
    <link href="https://fi3ework.github.io/2017-10-27/redux%20to%20react-redux/"/>
    <id>https://fi3ework.github.io/2017-10-27/redux to react-redux/</id>
    <published>2017-10-27T15:22:41.000Z</published>
    <updated>2017-12-12T13:15:55.907Z</updated>
    
    <content type="html"><![CDATA[<h3 id="redux的工作流程"><a href="#redux的工作流程" class="headerlink" title="redux的工作流程"></a>redux的工作流程</h3><ol><li><p>使用<code>createStore</code>创建一个管理数据的store。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> store = createStore(reducer)</div></pre></td></tr></table></figure><p>store的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">const</span> createStore = <span class="function">(<span class="params">reducer</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">let</span> state;</div><div class="line">  <span class="keyword">let</span> listeners = [];</div><div class="line"></div><div class="line">  <span class="keyword">const</span> getState = <span class="function"><span class="params">()</span> =&gt;</span> state;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> dispatch = <span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</div><div class="line">    state = reducer(state, action);</div><div class="line">    listeners.forEach(<span class="function"><span class="params">listener</span> =&gt;</span> listener());</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> subscribe = <span class="function">(<span class="params">listener</span>) =&gt;</span> &#123;</div><div class="line">    listeners.push(listener);</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      listeners = listeners.filter(<span class="function"><span class="params">l</span> =&gt;</span> l !== listener);</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="comment">// 在创建store的实例时先执行一次，将reducer的默认参数赋给state</span></div><div class="line">  dispatch(&#123;&#125;);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> &#123; getState, dispatch, subscribe &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>store就具有以下功能了：</p><ul><li>store.subscribe() - 向store设置监听函数，一旦 State 发生变化，就自动执行这个函数。</li><li>store.getState() - 通过闭包访问的真实的state被隐藏在store中，通过<code>store.getState()</code>来获取State。</li><li>store.dispatch() - 接受<code>action</code>来改变State，并执行所有监听的函数。</li><li>store.unsubscribe() - 不再监听对应的函数。</li></ul></li><li><p>用户通过UI的触发store的<code>dispatch</code>函数，在这一步中会自动调用<code>createStore</code>中作为参数的<code>reducer</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">store.dispath(action)</div></pre></td></tr></table></figure></li><li><p>store会自动调用使用<code>createStore</code>函数时传入的reducer，将<code>action</code>作为参数传给reducer，reducer会返回新的State，并会顺便执行所有监听的函数。</p></li></ol><ol><li><p>部分时候在多个组件中存在多个reducer，但是store只有一个，所以需要将所有reducer合并起来变成一个reducer用来<code>createStore</code>给store控制。使用的是<code>combineReducers</code>这个方法。</p><p>实现如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> combineReducers = <span class="function"><span class="params">reducers</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">state = &#123;&#125;, action</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.keys(reducers).reduce(</div><div class="line">      (nextState, key) =&gt; &#123;</div><div class="line">        nextState[key] = reducers[key](state[key], action);</div><div class="line">        <span class="keyword">return</span> nextState;</div><div class="line">      &#125;,</div><div class="line">      &#123;&#125; </div><div class="line">    );</div><div class="line">  &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>传入一个<code>action</code>会依次执行各个被合并的reducer，最后将各个reducer的结果组合成一个对象输出，各个reducer的键名就是传入的<code>reducers</code>中对应的key。</p><p>最后再用一张阮老师博客中的流程图表示</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016091802.jpg" alt="redux-process"></p><p>​</p></li></ol><h3 id="从redux到react-redux"><a href="#从redux到react-redux" class="headerlink" title="从redux到react-redux"></a>从redux到react-redux</h3><p>在react中使用react-redux能够更方便的管理状态。</p><blockquote><p>React-Redux 规定，所有的 UI 组件都由用户提供，容器组件则是由 React-Redux 自动生成。也就是说，用户负责视觉层，状态管理则是全部交给它。</p></blockquote><p>相比redux，react-redux主要多了以下几个方法：</p><ul><li><code>connect()</code> - 负责将用户写的UI组件和react-redux自动生成的容器组件连接起来。</li><li><code>mapStateToProps()</code> - 将作为react-redux自动生成的容器组件的属性传递给用户创建的UI组件，如果这些属性发生变化，会引起UI组件的重新渲染。如果不给<code>connect</code>传递<code>mapStateToProps</code>，那么Store的更新将不会引起UI组件的更新。</li><li><code>mapDispatchToProps()</code> - 用来建立UI组件的参数到<code>store.dispatch</code>方法的映射。</li><li><code>&lt;Provider&gt;</code>组件</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;redux的工作流程&quot;&gt;&lt;a href=&quot;#redux的工作流程&quot; class=&quot;headerlink&quot; title=&quot;redux的工作流程&quot;&gt;&lt;/a&gt;redux的工作流程&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;使用&lt;code&gt;createStore&lt;/code&gt;创建一
      
    
    </summary>
    
    
      <category term="React" scheme="https://fi3ework.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>页面生命周期：DOMContentLoaded, load, beforeunload, unload</title>
    <link href="https://fi3ework.github.io/2017-10-08/%E9%A1%B5%E9%9D%A2%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9ADOMContentLoaded,%20load,%20beforeunload,%20unload/"/>
    <id>https://fi3ework.github.io/2017-10-08/页面生命周期：DOMContentLoaded, load, beforeunload, unload/</id>
    <published>2017-10-08T07:21:31.000Z</published>
    <updated>2018-01-14T15:28:04.737Z</updated>
    
    <content type="html"><![CDATA[<p>原文地址：<a href="http://javascript.info/onload-ondomcontentloaded" target="_blank" rel="external">http://javascript.info/onload-ondomcontentloaded</a></p><p>HTML页面的生命周期有以下三个重要事件：</p><ul><li><code>DOMContentLoaded</code> — 浏览器已经完全加载了HTML，DOM树已经构建完毕，但是像是  <code>&lt;img&gt;</code> 和样式表等外部资源可能并没有下载完毕。  </li><li><code>load</code> — 浏览器已经加载了所有的资源（图像，样式表等）。</li><li><code>beforeunload/unload</code> – 当用户离开页面的时候触发。</li></ul><p>每个事件都有特定的用途</p><ul><li><code>DOMContentLoaded</code> – DOM加载完毕，所以js可以访问所有DOM节点，初始化界面。</li><li><code>load</code> – 附加资源已经加载完毕，可以在此事件触发时获得图像的大小（如果没有被在HTML/CSS中指定）</li><li><code>beforeunload/unload</code> – 用户正在离开页面：可以询问用户是否保存了更改以及是否确定要离开页面。</li></ul><p>来看一下每个事件的细节。</p><h2 id="DOMContentLoaded"><a href="#DOMContentLoaded" class="headerlink" title="DOMContentLoaded"></a>DOMContentLoaded</h2><p> <code>DOMContentLoaded</code> 由 <code>document</code> 对象触发。</p><p>我们使用 <code>addEventListener</code> 来监听它：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">document</span>.addEventListener(<span class="string">"DOMContentLoaded"</span>, ready);</div></pre></td></tr></table></figure><p>举个例子</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">ready</span>(<span class="params"></span>) </span>&#123;</span></div><div class="line"><span class="javascript">    alert(<span class="string">'DOM is ready'</span>);</span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="javascript">    <span class="comment">// image is not yet loaded (unless was cached), so the size is 0x0</span></span></div><div class="line"><span class="javascript">    alert(<span class="string">`Image size: <span class="subst">$&#123;img.offsetWidth&#125;</span>x<span class="subst">$&#123;img.offsetHeight&#125;</span>`</span>);</span></div><div class="line"><span class="undefined">  &#125;</span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="javascript">  <span class="built_in">document</span>.addEventListener(<span class="string">"DOMContentLoaded"</span>, ready);</span></div><div class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">"img"</span> <span class="attr">src</span>=<span class="string">"https://en.js.cx/clipart/train.gif?speed=1&amp;cache=0"</span>&gt;</span></div></pre></td></tr></table></figure><p>在这个例子中 <code>DOMContentLoaded</code>在document加载完成后就被触发，无需等待其他资源的载入，所以<code>alert</code>输出的图像的大小为0。</p><p>这么看来<code>DOMContentLoaded</code> 似乎很简单，DOM树构建完毕之后就运行该事件，不过其实存在一些陷阱。</p><h3 id="DOMContentLoaded-和脚本"><a href="#DOMContentLoaded-和脚本" class="headerlink" title="DOMContentLoaded 和脚本"></a>DOMContentLoaded 和脚本</h3><p>当浏览器在解析HTML页面时遇到了 <code>&lt;script&gt;...&lt;/script&gt;</code> 标签，将无法继续构建DOM树（译注：UI渲染线程与JS引擎是互斥的，当JS引擎执行时UI线程会被挂起），必须立即执行脚本。所以 <code>DOMContentLoaded</code> 有可能在所有脚本执行完毕后触发。</p><p>外部脚本（带<code>src</code>的）的加载和解析也会暂停DOM树构建，所以 <code>DOMContentLoaded</code> 也会等待外部脚本。</p><p>不过有两个例外是带<code>async</code>和<code>defer</code>的外部脚本，他们告诉浏览器继续解析而不需要等待脚本的执行，所以用户可以在脚本加载完成前可以看到页面，有较好的用户体验。</p><p><code>async</code>和<code>defer</code>属性仅仅对外部脚本起作用，并且他们在<code>src</code>不存在时会被自动忽略。</p><p>它们都告诉浏览器继续处理页面上的内容，而在后台加载脚本，然后在脚本加载完毕后再执行。所以脚本不会阻塞DOM树的构建和页面的渲染。</p><p><strong>（译注：其实这里是不对的，带有<code>async</code>和<code>defer</code>的脚本的下载是和HTML的下载与解析是异步的，但是js的执行一定是和UI线程是互斥的，像下面这张图所示，<code>async</code>在下载完毕后的执行会阻塞HTML的解析）</strong></p><p><img src="https://i.stack.imgur.com/wfL82.png" alt=""></p><p>他们有两处不同：</p><table><thead><tr><th style="text-align:left"></th><th style="text-align:left"><code>async</code></th><th style="text-align:left"><code>defer</code></th></tr></thead><tbody><tr><td style="text-align:left">顺序</td><td style="text-align:left">带有<code>async</code>的脚本是优先执行先加载完的脚本，他们在页面中的顺序并不影响他们执行的顺序。</td><td style="text-align:left">带有<code>defer</code>的脚本按照他们在页面中出现的顺序依次执行。</td></tr><tr><td style="text-align:left"><code>DOMContentLoaded</code></td><td style="text-align:left">带有<code>async</code>的脚本也许会在页面没有完全下载完之前就加载，这种情况会在脚本很小或本缓存，并且页面很大的情况下发生。</td><td style="text-align:left">带有<code>defer</code>的脚本会在页面加载和解析完毕后执行，刚好在  <code>DOMContentLoaded</code><strong>之前</strong>执行。</td></tr></tbody></table><p>所以<code>async</code>用在那些完全不依赖其他脚本的脚本上。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">### DOMContentLoaded and styles</div><div class="line"></div><div class="line">External style sheets don't affect DOM, and so `DOMContentLoaded` does not wait for them.</div><div class="line">外部样式表并不会影响DOM，所以`DOMContentLoaded`并不会被他们阻塞。</div><div class="line">But there's a pitfall: if we have a script after the style, then that script must wait for the stylesheet to execute:</div><div class="line">不过仍然有一个陷阱：如果在样式后面有一个内联脚本，那么脚本必须等待样式先加载完。</div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"style.css"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="javascript">  <span class="comment">// the script doesn't not execute until the stylesheet is loaded</span></span></div><div class="line"><span class="javascript">  <span class="comment">// 脚本直到样式表加载完毕后才会执行。</span></span></div><div class="line"><span class="javascript">  alert(getComputedStyle(<span class="built_in">document</span>.body).marginTop);</span></div><div class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure><p>发生这种事的原因是脚本也许会像上面的例子中所示，去得到一些元素的坐标或者基于样式的属性。所以他们自然要等到样式加载完毕才可以执行。</p><p><code>DOMContentLoaded</code>需要等待脚本的执行，脚本又需要等待样式的加载。</p><h3 id="浏览器的自动补全"><a href="#浏览器的自动补全" class="headerlink" title="浏览器的自动补全"></a>浏览器的自动补全</h3><p>Firefox, Chrome和Opera会在<code>DOMContentLoaded</code>执行时自动补全表单。</p><p>例如，如果页面有登录的界面，浏览器记住了该页面的用户名和密码，那么在 <code>DOMContentLoaded</code>运行的时候浏览器会试图自动补全表单（如果用户设置允许）。</p><p>所以如果<code>DOMContentLoaded</code>被一个需要长时间执行的脚本阻塞，那么自动补全也会等待。你也许见过某些网站（如果你的浏览器开启了自动补全）—— 浏览器并不会立刻补全登录项，而是等到整个页面加载完毕后才填充。这就是因为在等待<code>DOMContentLoaded</code>事件。</p><p>使用带<code>async</code>和<code>defer</code>的脚本的一个好处就是，他们不会阻塞<code>DOMContentLoaded</code>和浏览器自动补全。（译注：其实执行还是会阻塞的）</p><h2 id="window-onload"><a href="#window-onload" class="headerlink" title="window.onload"></a>window.onload</h2><p><code>window</code>对象上的<code>onload</code>事件在所有文件包括样式表，图片和其他资源下载完毕后触发。</p><p>下面的例子正确检测了图片的大小，因为<code>window.onload</code>会等待所有图片的加载。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="javascript">  <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></div><div class="line"><span class="javascript">    alert(<span class="string">'Page loaded'</span>);</span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="javascript">    <span class="comment">// image is loaded at this time</span></span></div><div class="line"><span class="javascript">    alert(<span class="string">`Image size: <span class="subst">$&#123;img.offsetWidth&#125;</span>x<span class="subst">$&#123;img.offsetHeight&#125;</span>`</span>);</span></div><div class="line"><span class="undefined">  &#125;;</span></div><div class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">"img"</span> <span class="attr">src</span>=<span class="string">"https://en.js.cx/clipart/train.gif?speed=1&amp;cache=0"</span>&gt;</span></div></pre></td></tr></table></figure><h2 id="window-onunload"><a href="#window-onunload" class="headerlink" title="window.onunload"></a>window.onunload</h2><p>用户离开页面的时候，<code>window</code>对象上的<code>unload</code>事件会被触发，我们可以做一些不存在延迟的事情，比如关闭弹出的窗口，可是我们无法阻止用户转移到另一个页面上。</p><p>所以我们需要使用另一个事件 —  <code>onbeforeunload</code>。</p><h2 id="window-onbeforeunload"><a href="#window-onbeforeunload" class="headerlink" title="window.onbeforeunload"></a>window.onbeforeunload</h2><p>如果用户即将离开页面或者关闭窗口时，<code>beforeunload</code>事件将会被触发以进行额外的确认。</p><p>浏览器将显示返回的字符串，举个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.onbeforeunload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">"There are unsaved changes. Leave now?"</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>有些浏览器像Chrome和火狐会忽略返回的字符串取而代之显示浏览器自身的文本，这是为了安全考虑，来保证用户不受到错误信息的误导。</p><h2 id="readyState"><a href="#readyState" class="headerlink" title="readyState"></a>readyState</h2><p>如果我们在整个页面加载完毕后设置<code>DOMContentLoaded</code>会发生什么呢？</p><p>啥也没有，<code>DOMContentLoaded</code>不会被触发。</p><p>有一些情况我们无法确定页面上是否已经加载完毕，比如一个带有<code>async</code>的外部脚本的加载和执行是异步的（注：执行并不是异步的-_-）。在不同的网络状况下，脚本有可能是在页面加载完毕后执行也有可能是在页面加载完毕前执行，我们无法确定。所以我们需要知道页面加载的状况。</p><p><code>document.readyState</code>属性给了我们加载的信息，有三个可能的值：</p><ul><li><code>loading</code> 加载 - document仍在加载。</li><li><code>interactive</code> 互动 - 文档已经完成加载，文档已被解析，但是诸如图像，样式表和框架之类的子资源仍在加载。</li><li><code>complete</code> - 文档和所有子资源已完成加载。状态表示 <code>load</code> 事件即将被触发。</li></ul><p>所以我们可以检查 <code>document.readyState</code> 的状态，如果没有就绪可以选择挂载事件，如果已经就绪了就可以直接立即执行。</p><p>像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">work</span>(<span class="params"></span>) </span>&#123; <span class="comment">/*...*/</span> &#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (<span class="built_in">document</span>.readyState == <span class="string">'loading'</span>) &#123;</div><div class="line">  <span class="built_in">document</span>.addEventListener(<span class="string">'DOMContentLoaded'</span>, work);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  work();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>每当文档的加载状态改变的时候就有一个<code>readystatechange</code>事件被触发，所以我们可以打印所有的状态。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// current state</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.readyState);</div><div class="line"></div><div class="line"><span class="comment">// print state changes</span></div><div class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'readystatechange'</span>, () =&gt; <span class="built_in">console</span>.log(<span class="built_in">document</span>.readyState));</div></pre></td></tr></table></figure><p><code>readystatechange</code> 是追踪页面加载的一个可选的方法，很早之前就已经出现了。不过现在很少被使用了，为了保持完整性还是介绍一下它。</p><p><code>readystatechange</code>的在各个事件中的执行顺序又是如何呢？</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">text</span>) </span>&#123; <span class="comment">/* output the time and message */</span> &#125;</span></div><div class="line"><span class="javascript">  log(<span class="string">'initial readyState:'</span> + <span class="built_in">document</span>.readyState);</span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="javascript">  <span class="built_in">document</span>.addEventListener(<span class="string">'readystatechange'</span>, () =&gt; log(<span class="string">'readyState:'</span> + <span class="built_in">document</span>.readyState));</span></div><div class="line"><span class="javascript">  <span class="built_in">document</span>.addEventListener(<span class="string">'DOMContentLoaded'</span>, () =&gt; log(<span class="string">'DOMContentLoaded'</span>));</span></div><div class="line"><span class="undefined"></span></div><div class="line"><span class="javascript">  <span class="built_in">window</span>.onload = <span class="function"><span class="params">()</span> =&gt;</span> log(<span class="string">'window onload'</span>);</span></div><div class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"iframe.html"</span> <span class="attr">onload</span>=<span class="string">"log('iframe onload')"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://en.js.cx/clipart/train.gif"</span> <span class="attr">id</span>=<span class="string">"img"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="javascript">  img.onload = <span class="function"><span class="params">()</span> =&gt;</span> log(<span class="string">'img onload'</span>);</span></div><div class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure><p>输出如下:</p><ol><li>[1] initial readyState:loading</li><li>[2] readyState:interactive</li><li>[2] DOMContentLoaded</li><li>[3] iframe onload</li><li>[4] readyState:complete</li><li>[4] img onload</li><li>[4] window onload</li></ol><p>方括号中的数字表示他们发生的时间，真实的发生时间会更晚一点，不过相同数字的时间可以认为是在同一时刻被按顺序触发（误差在几毫秒之内）</p><ul><li><code>document.readyState</code> 在 <code>DOMContentLoaded</code>前一刻变为<code>interactive</code>，这两个事件可以认为是同时发生。</li><li><code>document.readyState</code> 在所有资源加载完毕后（包括<code>iframe</code>和<code>img</code>）变成<code>complete</code>，我们可以看到<code>complete</code>、 <code>img.onload</code>和<code>window.onload</code>几乎同时发生，区别就是<code>window.onload</code>在所有其他的<code>load</code>事件之后执行。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>页面事件的生命周期：</p><ul><li><code>DOMContentLoaded</code>事件在DOM树构建完毕后被触发，我们可以在这个阶段使用js去访问元素。<ul><li><code>async</code>和<code>defer</code>的脚本可能还没有执行。</li><li>图片及其他资源文件可能还在下载中。</li></ul></li><li><code>load</code>事件在页面所有资源被加载完毕后触发，通常我们不会用到这个事件，因为我们不需要等那么久。</li><li><code>beforeunload</code>在用户即将离开页面时触发，它返回一个字符串，浏览器会向用户展示并询问这个字符串以确定是否离开。</li><li><code>unload</code>在用户已经离开时触发，我们在这个阶段仅可以做一些没有延迟的操作，由于种种限制，很少被使用。</li><li><code>document.readyState</code>表征页面的加载状态，可以在<code>readystatechange</code>中追踪页面的变化状态：<ul><li><code>loading</code> — 页面正在加载中。</li><li><code>interactive</code> – 页面解析完毕，时间上和 <code>DOMContentLoaded</code>同时发生，不过顺序在它之前。</li><li><code>complete</code> – 页面上的资源都已加载完毕，时间上和<code>window.onload</code>同时发生，不过顺序在他之前。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文地址：&lt;a href=&quot;http://javascript.info/onload-ondomcontentloaded&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://javascript.info/onload-ondomcontent
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://fi3ework.github.io/tags/JavaScript/"/>
    
      <category term="浏览器" scheme="https://fi3ework.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>hexo-theme-archer</title>
    <link href="https://fi3ework.github.io/2017-08-14/hexo-theme-archer/"/>
    <id>https://fi3ework.github.io/2017-08-14/hexo-theme-archer/</id>
    <published>2017-08-13T16:02:12.000Z</published>
    <updated>2017-11-04T09:02:03.826Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2017-08-14/hexo-theme-archer/snap.png" alt="preview"></p><p>安装及使用方法见GitHub地址: <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank" rel="external">戳我:)</a></p><h2 id="帮助"><a href="#帮助" class="headerlink" title="帮助"></a>帮助</h2><p>如果有任何使用上的问题或者疑问，欢迎留言</p><p>感谢使用😆</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2017-08-14/hexo-theme-archer/snap.png&quot; alt=&quot;preview&quot;&gt;&lt;/p&gt;
&lt;p&gt;安装及使用方法见GitHub地址: &lt;a href=&quot;https://github.com/fi3ework/hexo-theme-archer&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;戳我:)&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;帮助&quot;&gt;&lt;a href=&quot;#帮助&quot; class=&quot;headerlink&quot; title=&quot;帮助&quot;&gt;&lt;/a&gt;帮助&lt;/h2&gt;&lt;p&gt;如果有任何使用上的问题或者疑问，欢迎留言&lt;/p&gt;
&lt;p&gt;感谢使用😆&lt;/p&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="https://fi3ework.github.io/tags/hexo/"/>
    
      <category term="hexo-theme-archer" scheme="https://fi3ework.github.io/tags/hexo-theme-archer/"/>
    
  </entry>
  
  <entry>
    <title>client/scroll/offset width/height总结</title>
    <link href="https://fi3ework.github.io/2017-06-21/client:scroll:offset%20width:height%E6%80%BB%E7%BB%93/"/>
    <id>https://fi3ework.github.io/2017-06-21/client:scroll:offset width:height总结/</id>
    <published>2017-06-21T13:08:51.000Z</published>
    <updated>2017-06-21T15:24:50.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><h4 id="Element-clientHeight-amp-Element-clientWidth"><a href="#Element-clientHeight-amp-Element-clientWidth" class="headerlink" title="Element.clientHeight &amp; Element.clientWidth"></a>Element.clientHeight &amp; Element.clientWidth</h4><h5 id="element-clientHeight（只读）"><a href="#element-clientHeight（只读）" class="headerlink" title="element.clientHeight（只读）"></a>element.clientHeight（只读）</h5><blockquote><p>返回元素内部的高度(单位像素)，包含内边距，但不包括水平滚动条、边框和外边距。</p><p><code>clientHeight</code> 可以通过 CSS <code>height</code> + CSS <code>padding</code> - 水平滚动条高度 (如果存在)来计算.</p><h5 id="Element-clientWidth（只读）"><a href="#Element-clientWidth（只读）" class="headerlink" title="Element.clientWidth（只读）"></a>Element.clientWidth（只读）</h5><p><code>Element.clientWidth</code> 属性表示元素的内部宽度，以像素计。该属性<strong>包括内边距，但不包括垂直滚动条（如果有的话）、边框和外边距</strong>。</p></blockquote><p><img src="https://developer.mozilla.org/@api/deki/files/185/=Dimensions-client.png" alt="element.clientHeight"></p></li><li><h4 id="Element-clientLeft（只读）-amp-Element-clientTop（只读）"><a href="#Element-clientLeft（只读）-amp-Element-clientTop（只读）" class="headerlink" title="Element.clientLeft（只读）&amp; Element.clientTop（只读）"></a>Element.clientLeft（只读）&amp; Element.clientTop（只读）</h4><blockquote><p>表示一个元素的左边框的宽度，以像素表示。如果元素的文本方向是从右向左（RTL, right-to-left），并且由于内容溢出导致左边出现了一个垂直滚动条，则该属性包括滚动条的宽度。<strong><code>clientLeft</code> 不包括左外边距和左内边距</strong>。<code>clientLeft</code> 是只读的。</p><p>一个元素顶部边框的宽度（以像素表示）。不包括顶部外边距或内边距。<code>clientTop</code> 是只读的。</p></blockquote></li><li><h4 id="Element-scrollTop（读写）"><a href="#Element-scrollTop（读写）" class="headerlink" title="Element.scrollTop（读写）"></a>Element.scrollTop（读写）</h4><blockquote><p><code>这个Element.scrollTop</code> 属性可以设置或者获取一个元素距离他容器顶部的像素距离。一个元素的 <code>scrollTop</code> 是可以去计算出这个<strong>元素距离它容器顶部的可见高度</strong>。当一个元素的容器没有产生垂直方向的滚动条,那它的 <code>scrollTop 的值默认为0</code>.</p></blockquote><ul><li>如果一个元素不能被滚动 (e.g. 它没有溢出容器或者 这个元素是不可滚动的), <code>scrollTop被设置为0</code>.</li><li>设置scrollTop的值小于0，<code>scrollTop</code> 被设为<code>0</code></li><li><p>如果设置了超出这个容器可滚动的值, <code>scrollTop</code> 会被设为最大值.</p><p><img src="https://developer.mozilla.org/@api/deki/files/842/=ScrollTop.png" alt="element.scrollTop"></p></li></ul></li><li><h4 id="Element-scrollLeft（读写）"><a href="#Element-scrollLeft（读写）" class="headerlink" title="Element.scrollLeft（读写）"></a>Element.scrollLeft（读写）</h4><blockquote><p> <strong>Element.scrollLeft</strong> 属性可以读取或设置元素滚动条到元素左边的距离。注意如果这个元素的内容排列方向（<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/direction" target="_blank" rel="external"><code>direction</code></a>） 是<code>rtl</code> (right-to-left) ，那么滚动条会位于最右侧（内容开始处），并且scrollLeft值为0。此时，当你从右到左拖动滚动条时，scrollLeft会从0变为负数（这个特性在chrome浏览器中不存在）。</p></blockquote><ul><li>如果元素不能滚动（比如：元素没有溢出），那么<code>scrollLeft</code> 的值是0。</li><li>如果给<code>scrollLeft</code> 设置的值小于0，那么<code>scrollLeft</code> 的值将变为0。</li><li>如果给<code>scrollLeft</code> 设置的值大于元素内容最大宽度，那么<code>scrollLeft</code> 的值将被设为元素最大宽度。</li></ul></li><li><h4 id="ELement-scrollHeight（只读）-amp-Element-scrollHeigt（只读）"><a href="#ELement-scrollHeight（只读）-amp-Element-scrollHeigt（只读）" class="headerlink" title="ELement.scrollHeight（只读） &amp; Element.scrollHeigt（只读）"></a>ELement.scrollHeight（只读） &amp; Element.scrollHeigt（只读）</h4><blockquote><p><code>Element.scrollHeight</code> 是计量元素内容高度的只读属性，包括overflow样式属性导致的视图中不可见内容。没有垂直滚动条的情况下，scrollHeight值与元素视图填充所有内容所需要的最小值clientHeight相同。<strong>包括元素的padding，但不包括元素的margin.</strong></p><p><strong>Element.scrollHeight</strong> 是计量元素内容高度的只读属性，包括overflow样式属性导致的视图中不可见内容。没有垂直滚动条的情况下，scrollHeight值与元素视图填充所有内容所需要的最小值clientHeight相同。包括元素的padding，但不包括元素的margin.</p></blockquote></li></ul><p><img src="https://developer.mozilla.org/@api/deki/files/840/=ScrollHeight.png" alt="element.scrollHeight"></p><ul><li><h4 id="HTMLElement-offsetHegiht（只读）-amp-HTMLElement-offsetWidth（只读）"><a href="#HTMLElement-offsetHegiht（只读）-amp-HTMLElement-offsetWidth（只读）" class="headerlink" title="HTMLElement.offsetHegiht（只读）&amp; HTMLElement.offsetWidth（只读）"></a>HTMLElement.offsetHegiht（只读）&amp; HTMLElement.offsetWidth（只读）</h4><blockquote><p>HTMLElement.offsetHeight 是一个只读属性，它返回该元素的像素高度，高度包含该元素的垂直内边距和边框，且是一个整数。</p><p>通常，<strong>元素的offsetHeight是一种衡量标准，包括元素的边框、垂直内边距和元素的水平滚动条（如果存在且渲染的话）和元素的CSS高度。</strong></p><p>对于文档的主体对象，它包括代替元素的CSS高度线性总含量高。浮动元素的向下延伸内容高度是被忽略的。 </p><p><strong>HTMLElement.offsetWidth</strong> 是一个只读属性，返回一个元素的布局宽度。一个典型的（译者注：各浏览器的offsetWidth可能有所不同）<strong>offsetWidth是测量元素的边框(border)、水平线上的内边距(padding)、竖直方向滚动条(scroolbar)（如果存在的话）、以及CSS设置的宽度(width)的值。</strong></p></blockquote></li></ul><p><img src="https://developer.mozilla.org/@api/deki/files/186/=Dimensions-offset.png" alt="HTMLElement.offsetHegiht"></p><ul><li><h4 id="HTMLElement-offsetParent（只读）"><a href="#HTMLElement-offsetParent（只读）" class="headerlink" title="HTMLElement.offsetParent（只读）"></a><strong>HTMLElement.offsetParent</strong>（只读）</h4><blockquote><p><strong>HTMLElement.offsetParent</strong> 是一个只读属性，返回一个指向最近的（closest，指包含层级上的最近）包含该元素的定位元素。如果没有定位的元素，则 <code>offsetParent</code> 为最近的 <code>table</code>元素对象或根元素（标准模式下为 <code>html</code>；quirks 模式下为 <code>body</code>）。当元素的 <code>style.display</code> 设置为 “none” 时，<code>offsetParent</code> 返回 <code>null</code>。<code>offsetParent</code> 很有用，<strong>因为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLElement/offsetTop" target="_blank" rel="external"><code>offsetTop</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLElement/offsetLeft" target="_blank" rel="external"><code>offsetLeft</code></a> 都是相对于其内边距边界的。</strong></p></blockquote><h5 id="浏览器兼容性"><a href="#浏览器兼容性" class="headerlink" title="浏览器兼容性"></a>浏览器兼容性</h5><p>   在 Webkit 中，如果元素为隐藏的（该元素或其祖先元素的 <code>style.display</code> 为 “none”），或者该元素的 <code>style.position</code> 被设为 “fixed”，则该属性返回 <code>null</code>。</p><p>   在 IE 9 中，如果该元素的 <code>style.position</code> 被设置为 “fixed”，则该属性返回 <code>null</code>。（<code>display:none</code> 无影响。）</p></li><li><h4 id="HTMLElement-offsetLeft（只读）-amp-HTMLElement-offsetTop（只读）"><a href="#HTMLElement-offsetLeft（只读）-amp-HTMLElement-offsetTop（只读）" class="headerlink" title="HTMLElement.offsetLeft（只读）&amp; HTMLElement.offsetTop（只读）"></a>HTMLElement.offsetLeft（只读）&amp; HTMLElement.offsetTop（只读）</h4><blockquote><p> <strong>HTMLElement.offsetLeft</strong> 是一个只读属性，返回当前元素<em>左上角</em>相对于  <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLElement/offsetParent" target="_blank" rel="external"><code>HTMLElement.offsetParent</code></a> 节点的左边界<strong>（内边距边界）</strong>偏移的像素值。</p><p> 对块级元素来说，<code>offsetTop</code>、<code>offsetLeft</code>、<code>offsetWidth</code> 及 <code>offsetHeight</code> 描述了元素相对于 <code>offsetParent</code> 的边界框。</p><p> 然而，对于可被截断到下一行的行内元素（如 <strong>span</strong>），<code>offsetTop</code> 和 <code>offsetLeft</code> 描述的是<em>第一个</em>边界框的位置（使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getClientRects" target="_blank" rel="external"><code>Element.getClientRects()</code></a> 来获取其宽度和高度），而 <code>offsetWidth</code> 和 <code>offsetHeight</code> 描述的是边界框的维度（使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect" target="_blank" rel="external"><code>Element.getBoundingClientRect</code></a> 来获取其位置）。因此，使用 <code>offsetLeft、offsetTop、offsetWidth</code>、<code>offsetHeight</code> 来对应 left、top、width 和 height 的一个盒子将不会是文本容器 span 的盒子边界。</p><p><strong>HTMLElement.offsetTop</strong> 为只读属性，它返回当前元素相对于其 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLElement/offsetParent" target="_blank" rel="external"><code>offsetParent</code></a> 元素的顶部的距离。</p></blockquote></li></ul><h3 id="总结图"><a href="#总结图" class="headerlink" title="总结图"></a>总结图</h3><p><img src="https://i.stack.imgur.com/zWca7.png" alt="Microsoft has a nice image in the MSDN:"></p><p><img src="https://i.stack.imgur.com/5AAyW.png" alt=""></p><p><img src="http://pic002.cnblogs.com/images/2011/85285/2011102915280329.jpg" alt=""><br><img src="https://i.stack.imgur.com/NANud.png" alt=""> <img src="https://i.stack.imgur.com/RFxSh.png" alt=""></p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul><li><code>clientHegiht</code> <code>clientWidth</code>：包括padding，不包括border的可见区域大小，不能通过CSS计算得到大小，因为不知道滚动条的大小。</li></ul><ul><li><p><code>offsetHeight</code> <code>offsetWidth</code>：包括border， padding和滚动条的可见区域大小，可以通过<code>width + padding</code>得到大小。</p></li><li><p><code>scrollHeight</code> <code>scrollWidth</code>，页面内容的总长度，<strong>不包括border</strong>，不能通过CSS计算大小。</p><p>​</p></li></ul><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul><li><p>判断滚动元素是否到底（比如安装软件时的协议条款）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">element.scrollHeight - element.scrollTop === element.clientHegiht;</div></pre></td></tr></table></figure></li></ul><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li>MDN</li></ul><ul><li><a href="https://stackoverflow.com/questions/21064101/understanding-offsetwidth-clientwidth-scrollwidth-and-height-respectively" target="_blank" rel="external">Understanding offsetWidth, clientWidth, scrollWidth and -Height, respectively</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;h4 id=&quot;Element-clientHeight-amp-Element-clientWidth&quot;&gt;&lt;a href=&quot;#Element-clientHeight-amp-Element-clientWidth&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://fi3ework.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>SASS的map</title>
    <link href="https://fi3ework.github.io/2017-06-19/SASS%E7%9A%84map/"/>
    <id>https://fi3ework.github.io/2017-06-19/SASS的map/</id>
    <published>2017-06-19T14:55:21.000Z</published>
    <updated>2017-06-21T15:25:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天在看SASS中文网时发现<code>Maps</code>没有翻译，就顺便翻译一下。</p><blockquote><h4 id="6-3-3-Maps"><a href="#6-3-3-Maps" class="headerlink" title="6.3.3. Maps"></a>6.3.3. Maps</h4><p>Maps represent an association between keys and values, where keys are used to look up values. They make it easy to collect values into named groups and access those groups dynamically. They have no direct parallel in CSS, although they’re syntactically similar to media query expressions: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; scss $map: (key1: value1, key2: value2, key3: value3);</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p> Unlike lists, maps must always be surrounded by parentheses and must always be comma-separated. Both the keys and values in maps can be any SassScript object. A map may only have one value associated with a given key (although that value may be a list). A given value may be associated with many keys, though. Like lists, maps are mostly manipulated using SassScript functions. The map-get function looks up values in a map and the map-merge function adds values to a map. The @each directive can be used to add styles for each key/value pair in a map. The order of pairs in a map is always the same as when the map was created. Maps can also be used anywhere lists can. When used by a list function, a map is treated as a list of pairs. For example, (key1: value1, key2: value2) would be treated as the nested list key1 value1, key2 value2 by list functions. Lists cannot be treated as maps, though, with the exception of the empty list. () represents both a map with no key/value pairs and a list with no elements. Note that map keys can be any Sass data type (even another map) and the syntax for declaring a map allows arbitrary SassScript expressions that will be evaluated to determine the key. Maps cannot be converted to plain CSS. Using one as the value of a variable or an argument to a CSS function will cause an error. Use the inspect($value) function to produce an output string useful for debugging maps.</p></blockquote><p><strong>翻译如下：</strong></p><p>Maps代表键值对之间的映射，通过key来索引value。这使得可以很容易的将值集合在对象中并且能够动态的更新对象。CSS语法中没有直接与Map对应的语法，尽管Map的语法很像是<code>media query</code>表达式</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scss <span class="variable">$map</span>: (key1: value1, key2: value2, key3: value3);</div></pre></td></tr></table></figure><p>与list不同，map必须包含在一对圆括号中，也必须使用逗号分隔。键与值可以为ScssScript中的 任何对象。在一个map中，一个key只能对应一个value（value可以是list），但一个value可以对应多个key。与list类似，map一般用来进行ScssScript的操作，<code>map-get</code>函数用来在map中索引，<code>map-merge</code>函数用来向map添加键值对。<code>@each</code>命令可以给map中的键值对添加样式。map中键值对的顺序取决于创建时的顺序。凡是可以使用list的地方都可以使用map，当list的函数操作map时，会将map看做一个由键值对组成的数组。比如<code>(key1: value1, key2: value2)</code>会被看成嵌套的list：<code>[key1, value1],[key2, value2]</code>（待定）。但是list不能被当做map使用，除了空数组。<code>()</code>既代表一个空数组也代表一个没有键值对的map。key可以为任何的Sass数据格式（可以是另一个map）。Map不能直接转换为CSS语法，当被CSS函数当做值或者变量或者参数时将会导致错误，使用<code>inspect($value)</code>函数可以用来生成调试map的字符串函数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天在看SASS中文网时发现&lt;code&gt;Maps&lt;/code&gt;没有翻译，就顺便翻译一下。&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;6-3-3-Maps&quot;&gt;&lt;a href=&quot;#6-3-3-Maps&quot; class=&quot;headerlink&quot; title=&quot;6.3.3. 
      
    
    </summary>
    
    
      <category term="SASS" scheme="https://fi3ework.github.io/tags/SASS/"/>
    
  </entry>
  
  <entry>
    <title>CSS常用布局方式</title>
    <link href="https://fi3ework.github.io/2017-06-09/CSS%E5%B8%B8%E7%94%A8%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F/"/>
    <id>https://fi3ework.github.io/2017-06-09/CSS常用布局方式/</id>
    <published>2017-06-08T17:03:46.000Z</published>
    <updated>2017-06-10T14:06:46.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="高度相等的列"><a href="#高度相等的列" class="headerlink" title="高度相等的列"></a>高度相等的列</h3><p>  <img src="/2017-06-09/CSS常用布局方式/./CSS常用布局方式/高度相等的列.png" alt="高度相等的列"></p><p>  思路：三列浮动布局，给每列一个很大的<code>padding-bottom</code>，然后每列的<code>margin-bottom</code>比<code>padding-bottom</code>稍小，外面包裹的<code>wrapper</code>就会被最高的一列撑起来。</p><p>  代码：</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.box</span> &#123;</div><div class="line">  <span class="attribute">width</span>: <span class="number">250px</span>;</div><div class="line">  <span class="attribute">margin-left</span>: <span class="number">20px</span>;</div><div class="line">  <span class="attribute">float</span>: left;</div><div class="line">  <span class="attribute">padding</span>: <span class="number">10px</span>;</div><div class="line">  <span class="attribute">background-color</span>: orange;</div><div class="line">  <span class="attribute">padding-bottom</span>: <span class="number">520px</span>;</div><div class="line">  <span class="attribute">margin-bottom</span>: -<span class="number">500px</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.wrapper</span> &#123;</div><div class="line">  <span class="attribute">overflow</span>: hidden;</div><div class="line">&#125;</div></pre></td></tr></table></figure>  <figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Andy Budd<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Andy is the Managing Director of Clearleft. He also goes by the title of User Experience Director depending what mood</div><div class="line">      he’s in. Andy is the author of CSS Mastery, curates the dConstruct and UX London events and is responsible for Silverbackapp,</div><div class="line">      our low cost usability testing application for the Mac.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"bottom"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Richard Rutter<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Richard is a founding partner and the production director for Clearleft. He has been designing websites and web applications</div><div class="line">      since the birth of the commercial web, over twelve years ago. Richard leads the user experience team at Clearleft, pioneering</div><div class="line">      innovative approaches to designing fantastic experiences for clients and their customers.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"bottom"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Jeremy Keith<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Jeremy is a hugely experienced developer specialising in XHTML, CSS, Javascript and PHP-driven solutions. Jeremy is technical</div><div class="line">      director at Clearleft.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"bottom"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><h3 id="解决浮动元素溢出问题"><a href="#解决浮动元素溢出问题" class="headerlink" title="解决浮动元素溢出问题"></a>解决浮动元素溢出问题</h3><ul><li><p>在外围<code>div</code>底部添加一个<code>&lt;br /&gt;</code>然后设定<code>br {clear: both};</code>（需要添加额外的html）。</p></li><li><p>将外围div设定为<code>float</code>（但是容器后面的的元素要设定<code>clear</code>）</p></li><li><p>将外围块设定为<code>overflow: hidden;</code>， <code>overhidden</code>会强制外围块放大到包含浮动元素，如果是ie6及之前的浏览器，再添加<code>zoom: 1;</code>不过如果<code>div</code>中有绝对定位的元素时，可能显现不出来。</p></li><li><p>使用简单清除法（需要添加额外的html）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 清理浮动 */</span>  </div><div class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123;  </div><div class="line">    <span class="attribute">content</span>:<span class="string">""</span>;  </div><div class="line">    <span class="attribute">display</span>:block;  </div><div class="line">    <span class="attribute">height</span>:<span class="number">0</span>;  </div><div class="line">    <span class="attribute">font-size</span>:<span class="number">0</span>;  </div><div class="line">    <span class="attribute">clear</span>:both;  </div><div class="line">    <span class="attribute">visibility</span>:hidden;  </div><div class="line">&#125;  </div><div class="line"><span class="selector-class">.clearfix</span> &#123;  </div><div class="line">    <span class="attribute">zoom</span>:<span class="number">1</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"clearfix"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></li></ul><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;高度相等的列&quot;&gt;&lt;a href=&quot;#高度相等的列&quot; class=&quot;headerlink&quot; title=&quot;高度相等的列&quot;&gt;&lt;/a&gt;高度相等的列&lt;/h3&gt;&lt;p&gt;  &lt;img src=&quot;/2017-06-09/CSS常用布局方式/./CSS常用布局方式/高度相等的列.p
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CSS TIPS</title>
    <link href="https://fi3ework.github.io/2017-06-07/CSS%20TIPS/"/>
    <id>https://fi3ework.github.io/2017-06-07/CSS TIPS/</id>
    <published>2017-06-07T13:14:35.000Z</published>
    <updated>2018-01-20T17:03:28.128Z</updated>
    
    <content type="html"><![CDATA[<h3 id="html"><a href="#html" class="headerlink" title="html"></a>html</h3><ul><li><p>当网页中的内容较少时，html元素可能无法覆盖整个浏览器的高度，通过设置</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">html</span>&#123;</div><div class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>即可将整个页面撑开到浏览器的高度。</p></li></ul><h3 id="CSS高速缓存"><a href="#CSS高速缓存" class="headerlink" title="CSS高速缓存"></a>CSS高速缓存</h3><ul><li><p>CSS被缓存之后，可以通过如下方法，使之前的缓存失效</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"sytlesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"main.css?v=1"</span>&gt;</span></div></pre></td></tr></table></figure><p>只要每次更新样式表的时候<code>v=</code>后面的数字不同，就可以下载新的样式表了。</p></li></ul><h3 id="import的缺点"><a href="#import的缺点" class="headerlink" title="@import的缺点"></a>@import的缺点</h3><ul><li><p>在IE678中，<code>import</code>会被<code>link</code>阻塞，无法并行加载。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">'stylesheet'</span> <span class="attr">type</span>=<span class="string">'text/css'</span> <span class="attr">href</span>=<span class="string">'a.css'</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="css">@<span class="keyword">import</span> url(<span class="string">'b.css'</span>);</span></div><div class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div></pre></td></tr></table></figure><p><img src="http://stevesouders.com/tests/atimport/link-import.gif" alt="@import blocked by link"></p><p>如图。第一段是HTML的加载，第二段是a.css，第二段是b.css</p></li><li><p>如果是以下方式调用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">'stylesheet'</span> <span class="attr">type</span>=<span class="string">'text/css'</span> <span class="attr">href</span>=<span class="string">'a.css'</span>&gt;</span></div><div class="line">in a.css:</div><div class="line">@import url('b.css');</div></pre></td></tr></table></figure><p><img src="http://stevesouders.com/tests/atimport/link-with-import.gif" alt="link with @import"></p><p>浏览器要等到a.css下载完并并解析后才能去下载b.css，这在所有浏览器中偶是如此。</p></li><li><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">in the HTML document:</div><div class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">'stylesheet'</span> <span class="attr">type</span>=<span class="string">'text/css'</span> <span class="attr">href</span>=<span class="string">'a.css'</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">'stylesheet'</span> <span class="attr">type</span>=<span class="string">'text/css'</span> <span class="attr">href</span>=<span class="string">'proxy.css'</span>&gt;</span></div><div class="line">in proxy.css:</div><div class="line">@import url('b.css');</div></pre></td></tr></table></figure><p>如果是这种调用方式，在IE中会是如下</p><p><img src="http://stevesouders.com/tests/atimport/link-blocks-import.gif" alt="link blocks @import"></p><p>第一段是HTML，第二段是a.css，第三（小）段是proxy.css，可以看到link是可以并行下载的，最后一段时b.css，但是在IE中@import会被link阻塞，只能等到link的下载完毕才能开始下载。</p><p>在其他浏览器中顺序如下：</p><p><img src="http://stevesouders.com/tests/atimport/link-blocks-import-not-ie.gif" alt="link blocks @import"></p><p>第一段是HTML，第二段是a.css，第三段是proxy.css，显然link是可以并行下载的。第四段是b.css，需要等到proxy.css加载解析完毕后才能开始下载，但是在其他浏览器中并不会被link阻塞。</p></li><li><p>在IE678中</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="css">@<span class="keyword">import</span> url(<span class="string">'a.css'</span>);</span></div><div class="line"><span class="css">@<span class="keyword">import</span> url(<span class="string">'b.css'</span>);</span></div><div class="line"><span class="css">@<span class="keyword">import</span> url(<span class="string">'c.css'</span>);</span></div><div class="line"><span class="css">@<span class="keyword">import</span> url(<span class="string">'d.css'</span>);</span></div><div class="line"><span class="css">@<span class="keyword">import</span> url(<span class="string">'e.css'</span>);</span></div><div class="line"><span class="css">@<span class="keyword">import</span> url(<span class="string">'f.css'</span>);</span></div><div class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">'one.js'</span> <span class="attr">type</span>=<span class="string">'text/javascript'</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure><p><img src="http://stevesouders.com/tests/atimport/many-imports.gif" alt="many @imports"></p><p>（最长的那一段是js的代码）</p><p>可以看到尽管js的代码顺序排在最后，但是在加载的确实第一个，他们无法按照给定的顺序依次下载。所以如果加载的js代码对css有依赖的话就血崩了。</p></li><li><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">'stylesheet'</span> <span class="attr">type</span>=<span class="string">'text/css'</span> <span class="attr">href</span>=<span class="string">'a.css'</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">'stylesheet'</span> <span class="attr">type</span>=<span class="string">'text/css'</span> <span class="attr">href</span>=<span class="string">'b.css'</span>&gt;</span></div></pre></td></tr></table></figure><p><img src="http://stevesouders.com/tests/atimport/import-import.gif" alt="link link"></p><p>使用link链接能保证并行下载并且能够按照指定的顺序下载。</p></li><li><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">'stylesheet'</span> <span class="attr">type</span>=<span class="string">'text/css'</span> <span class="attr">href</span>=<span class="string">'proxy.css'</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">'one.js'</span> <span class="attr">type</span>=<span class="string">'text/javascript'</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">in proxy.css</div><div class="line">@import url('a.css');</div><div class="line">@import url('b.css');</div><div class="line">@import url('c.css');</div><div class="line">@import url('d.css');</div><div class="line">@import url('e.css');</div><div class="line">@import url('f.css');</div></pre></td></tr></table></figure><p><img src="http://stevesouders.com/tests/atimport/link-with-imports.gif" alt="link with many @imports"></p><p>第一段为HTML，第二段为proxy.css，最长的一段为js。一开始加载HTML，然后依次加载proxy.css和js，当a.css加载完毕后开始并行加载@import的css，与此同时js一直在加载，可以发现两个问题，一是js的下载可能会优先于css结束（IE678的问题），二是js一直占用着HTTP的连接数，导致css加载变慢（所有浏览器的问题）</p></li><li><p>参考文献：<a href="http://www.stevesouders.com/blog/2009/04/09/dont-use-import/" target="_blank" rel="external">don’t use @import</a></p></li></ul><h3 id="em-amp-px-amp"><a href="#em-amp-px-amp" class="headerlink" title="em &amp; px &amp; %"></a>em &amp; px &amp; %</h3><ul><li><code>em</code>指的是在不额外设置<code>line-height</code>时基线间的距离。</li><li>建议以<code>em</code>为单位设置<strong>容器的宽度</strong>，这样可以保障在字号增加时整个布局随之扩大。以<code>%</code>设置<strong>内部的宽度</strong>，这样父元素是<code>em</code>确定的大小，<code>%</code>还是相对于字号的。这样就可以方便的修改布局的总尺寸。</li></ul><h3 id="background"><a href="#background" class="headerlink" title="background:"></a>background:</h3><ul><li>CSS3可以设置多个<code>background-image</code>，并且可以分别设置<code>position</code>和<code>repeat</code>，使用逗号分隔。</li><li>通过将背景的不同的<code>background-image</code>的<code>background-position</code>设置为不同的百分比可以实现视差滑动。越前景的部分值越大（移动时需要动的越多）。</li><li><code>background</code>填充<code>padding</code>区域，会一直蔓延到<code>border</code>的下面，也就是说<code>border</code>盖住了<code>background</code>，如果<code>border</code>为<code>dashed</code>则可以看见下面的<code>background</code>。</li></ul><h3 id="link"><a href="#link" class="headerlink" title="link"></a>link</h3><ul><li>为了尽可能提高网页的可访问性，应在定义<code>:hover</code>伪类时同时<code>:focus</code>伪类，这样通过键盘移动到链接上时，能够获得与鼠标悬停同样的样式。 </li><li>在CSS3中，可为<code>#</code>链接点击目标添加伪类<code>:target</code>来做到跳转时的提示。</li></ul><h3 id="img"><a href="#img" class="headerlink" title="img"></a>img</h3><ul><li><code>url</code>的相对路径指的是相对于样式表的相对路径，而不是html页面的相对路径。</li></ul><h3 id="before-amp-after"><a href="#before-amp-after" class="headerlink" title="before &amp; after"></a>before &amp; after</h3><ul><li><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">p:before&#123;</div><div class="line">  content: url(images/test.jpg);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>就可以在<code>p</code>之前插入图片。还可以将文字与图片结合起来</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">p:before&#123;</div><div class="line">  content: "Paragraph" url(images/test.jpg);</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h3 id="font"><a href="#font" class="headerlink" title="font"></a>font</h3><ul><li><p>在使用简写属性<code>font</code>时，所有被忽略的值都会重置为其默认值。因此</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">h1</span> &#123;</div><div class="line">  <span class="attribute">font</span>: italic bold <span class="number">250%</span> sans-serif;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">h1</span>&#123;</div><div class="line">  <span class="attribute">font</span>: <span class="number">20px</span> sans-serif;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>最后只有<code>20px</code>和<code>sans-serif</code>被保存下来了，其他的都在第二次设置样式时被重置了，相当于</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">h1</span>&#123;</div><div class="line">  <span class="attribute">font</span>: normal normal normal <span class="number">20px</span> sans-serif;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h3 id="font-face"><a href="#font-face" class="headerlink" title="font-face"></a>font-face</h3><ul><li><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">font-face</span>&#123;</div><div class="line">  <span class="attribute">font-family</span>: Lavoisier;</div><div class="line">  <span class="attribute">src</span>: <span class="built_in">local</span>(Lavoisier),</div><div class="line">    <span class="built_in">url</span>(font/Lavoisier.ttf);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>使用<code>local</code>可以避免在本地具有<code>local</code>字体的情况下继续下载指定字体（直接使用<code>local</code>字体）。</p></li></ul><h3 id="line-height"><a href="#line-height" class="headerlink" title="line-height"></a>line-height</h3><ul><li><p>浏览器的默认行高一般是120%，在确定文本行之间的间距量时，浏览器一般从行高中间去字体大小。这个结果称作leading，就是段落中行与行之间的间距量。</p></li><li><p>一般使用<code>em</code>或<code>percent</code>来控制行高，这样能够随着<code>font-size</code>的大小自适应变化。</p></li><li><p><code>line-height</code>的属性继承需要注意。假设父元素的<code>font-size</code>为<code>20px</code>，子元素<code>font-size</code>为<code>40px</code>，父元素<code>line-height</code>设为<code>120%</code>或<code>1.2em</code>，<strong>则子元素继承的是父元素计算出来的行高的<code>px</code>值，而不是百分比</strong>，所以子元素的行高会等于20 * 1.2 = 24px而与子元素的<code>font-size</code>完全没有关系。</p><p> 如图所示。</p><p> <img src="/2017-06-07/CSS TIPS/line-height-inherit.png" alt="line-height inherit"></p><p> 所以如果希望实现按比例继承，直接使用<code>line-height: 1.5;</code>，这样子元素的行高将等于这个继承的比例乘以自己<code>font-size</code>。</p></li><li><p>设置单行文本（内联或块级元素时）的高度时，可以直接使用<code>line-height</code>来设置高度，好处是能够保持文本垂直居中。</p></li></ul><h3 id="clear"><a href="#clear" class="headerlink" title="clear:"></a>clear:</h3><ul><li><p><code>clear</code>实际上在元素顶上添加足够的外边距，使元素的顶边缘垂直下降到浮动框下边。</p><p>​</p></li></ul><h3 id="overflow-hidden"><a href="#overflow-hidden" class="headerlink" title="overflow: hidden"></a>overflow: hidden</h3><ul><li>ovh会使延伸到浮动下方的背景和边框消失，消失是从进入浮动元素的margin范围就开始生效。如图，红块具有<code>margin</code>，h1延伸到浮动元素<code>margin</code>的时候就开始截断了。<img src="/2017-06-07/CSS TIPS/ovh hidden bgc.png" alt="ovh hidden bgc"></li></ul><h3 id="text-transform"><a href="#text-transform" class="headerlink" title="text-transform"></a>text-transform</h3><ul><li><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">capitalize | uppercase | lowercase | (full-width)</div></pre></td></tr></table></figure><p>可以将文本首字母大写，转大写，转小写。</p></li></ul><h3 id="z-index"><a href="#z-index" class="headerlink" title="z-index"></a>z-index</h3><ul><li>绝对定位的元素处于网页的上层（z-index），绝对定位元素中的绝对定位元素无论<code>z-index</code>值为多少也在其包围元素之上。</li></ul><h3 id="行内元素"><a href="#行内元素" class="headerlink" title="行内元素"></a>行内元素</h3><ul><li><p>行内元素的水平间距可以通过水平内边距、水平外边距、水平边框来改变。垂直边框，垂直内边距，垂直外边距不会影响行内元素的高度，只有行高可以影响。</p></li><li><p>行框的高度总是足以容纳它所包含的所有行内框。</p></li><li><p>行内元素每一行都是叠加在上一行之上的，所以如果对下面的行内元素设置<code>padding</code>会覆盖上面的行内元素，这个覆盖是依照HTML中的顺序决定，而不是浏览器中渲染的位置决定的。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Andy Budd<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></div><div class="line">    Andy is the Managing Director of Clearleft. He also goes by the title of User Experience Director depending what mood</div><div class="line">    he’s in. Andy is the author of <span class="tag">&lt;<span class="name">em</span>&gt;</span>CSS Mastery<span class="tag">&lt;/<span class="name">em</span>&gt;</span>, curates the dConstruct and UX London events and is responsible for Silverbackapp,</div><div class="line">    our low cost usability testing application for the Mac.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"bottom"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"sp1"</span>&gt;</span>lower<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><p>如图，lower在HTML在黄字之后，但是通过css的设置排在了黄字上面，不过lower还是覆盖了黄字。</p><p><img src="/2017-06-07/CSS TIPS/inline-cover.png" alt="inline-cover"></p><p>​</p></li></ul><h3 id="外边距"><a href="#外边距" class="headerlink" title="外边距"></a>外边距</h3><ul><li><p>只有普通文档流中块框的垂直外边距才会发生外边距叠加。行内框、浮动框或绝对定位框之间的外边距不会叠加。（一个设置了<code>position: relative</code>的普通文档流元素也会和其他普通文档流元素发生外边距叠加）</p></li><li><p>外边距发生叠加的几种情况：</p><ul><li><p>普通外边距叠加</p><p><img src="/2017-06-07/CSS TIPS/./CSS TIPS/margin collapse 1.png" alt="margin collapse 1"></p></li><li><p>空元素（没有边框和内边距将两个外边距分隔开）</p><p><img src="/2017-06-07/CSS TIPS/./CSS TIPS/margin collapse 2.png" alt="margin collapse 1"></p></li><li><p>空元素（自身的<code>margin-top</code>和<code>margin-bottom</code>折叠了）</p><p><img src="/2017-06-07/CSS TIPS/./CSS TIPS/margin collapse 3.png" alt="margin collapse 1"></p></li><li><p>叠加之后的外边距只要满足条件就可以继续叠加</p><p><img src="/2017-06-07/CSS TIPS/./CSS TIPS/margin collapse 4.png" alt="margin collapse 1"></p></li></ul></li></ul><h3 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h3><ul><li><p>通过把伪类连接在一起，可以实现更复杂的行为，比如</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:visited</span><span class="selector-pseudo">:hover</span> &#123; <span class="attribute">color </span>: red; &#125;;</div><div class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span><span class="selector-pseudo">:visited</span> &#123; <span class="attribute">color </span>: red; &#125;;</div></pre></td></tr></table></figure><p>顺序顺序并没有影响。</p></li><li><p><code>hover</code> <code>active</code> <code>focus</code>理论上可以应用于所有的元素。</p></li><li><p>在下拉式菜单栏中，可以先</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#nav</span> <span class="selector-tag">li</span> <span class="selector-tag">ul</span> &#123;</div><div class="line">  <span class="attribute">position</span>: absolute;</div><div class="line">  <span class="attribute">left </span>: -<span class="number">999em</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>再在父列表项中添加鼠标悬停伪选择器，把下拉菜单的位置改回原来的正常位置。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#nav</span> <span class="selector-tag">li</span><span class="selector-pseudo">:hover</span> <span class="selector-tag">ul</span> &#123;</div><div class="line"><span class="attribute">left </span>: auto;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>即使鼠标悬停于某父元素的子元素上时，即使这个父元素并不在鼠标所在位置，或者这个父元素大小为0，也会触发父元素的<code>:hover</code>伪类。</p></li></ul><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ul><li>@todo来表示某些东西需要在以后进行修改、修复或复查</li><li>@bugfix表示代码或特定浏览器遇到的问题</li><li>@workaround表示并不完善的权宜之计</li></ul><h3 id="important"><a href="#important" class="headerlink" title="!important"></a>!important</h3><ul><li>当两个都有<code>!important</code>的样式应用于相同的属性时，更具体的 <code>!importat</code>规则将会胜出。</li></ul><h3 id="整体"><a href="#整体" class="headerlink" title="整体"></a>整体</h3><ul><li>一般性样式<ul><li>主体样式（应用于body标记的，应该由站点上所有元素继承的样式）</li><li>reset样式</li><li>链接</li><li>标题</li><li>其他元素</li></ul></li><li>辅助样式<ul><li>表单</li><li>通知和错误</li><li>一致的条目</li></ul></li><li>页面结构<ul><li>标题、页脚和导航</li><li>布局</li><li>其他页面结构元素</li></ul></li><li>页面组件<ul><li>各个页面</li></ul></li><li>覆盖</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;html&quot;&gt;&lt;a href=&quot;#html&quot; class=&quot;headerlink&quot; title=&quot;html&quot;&gt;&lt;/a&gt;html&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;当网页中的内容较少时，html元素可能无法覆盖整个浏览器的高度，通过设置&lt;/p&gt;
&lt;figure clas
      
    
    </summary>
    
      <category term="技术" scheme="https://fi3ework.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CSS" scheme="https://fi3ework.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>HTML5大纲及计算方法</title>
    <link href="https://fi3ework.github.io/2017-06-06/HTML5%E5%A4%A7%E7%BA%B2%E5%8F%8A%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95/"/>
    <id>https://fi3ework.github.io/2017-06-06/HTML5大纲及计算方法/</id>
    <published>2017-06-06T15:55:21.000Z</published>
    <updated>2017-06-07T15:51:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTML5大纲及计算方法"><a href="#HTML5大纲及计算方法" class="headerlink" title="HTML5大纲及计算方法"></a>HTML5大纲及计算方法</h1><h3 id="HTML5的好处"><a href="#HTML5的好处" class="headerlink" title="HTML5的好处"></a>HTML5的好处</h3><ol><li><p>在HTML4中定义章节性段落往往需要<code>&lt;div&gt;</code>，但<code>&lt;div&gt;</code>有时又扮演着表达样式的作用，所以在HTML4中章节的定义和范围都是不精确的。在HTML5中，<code>&lt;div&gt;</code>不再计入大纲算法。</p></li><li><p>如果在主文档中嵌套了子文档（比如在一个<code>h2</code>文档中又出现一个<code>h1</code>文档），会造成大纲的混乱。引入新的元素<code>&lt;article&gt;</code>,<code>&lt;section&gt;</code>,<code>&lt;nav&gt;</code>和<code>&lt;aside&gt;</code>，他们总是成为其最近祖先章节的子章节。</p></li><li><p><code>&lt;aside&gt;</code>元素不会插入到大纲当中，可以用来容纳广告或者解释区域。</p></li></ol><h3 id="HTML5的大纲算法"><a href="#HTML5的大纲算法" class="headerlink" title="HTML5的大纲算法"></a>HTML5的大纲算法</h3><blockquote><p> <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/body" target="_blank" rel="external"><code>&lt;body&gt;</code></a> 元素中的所有内容都是节段中的一部分。节段在HTML5中是可以嵌套的。<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/body" target="_blank" rel="external"><code>&lt;body&gt;</code></a> 元素定义了主节段，基于主节段，可以显式或隐式定义各个子节段的划分。</p></blockquote><h4 id="显式分节"><a href="#显式分节" class="headerlink" title="显式分节"></a>显式分节</h4><blockquote><p>显式定义的节段是通过<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/body" target="_blank" rel="external"><code>&lt;body&gt;</code></a>,  <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/section" target="_blank" rel="external"><code>&lt;section&gt;</code></a>,  <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/article" target="_blank" rel="external"><code>&lt;article&gt;</code></a>,  <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/aside" target="_blank" rel="external"><code>&lt;aside&gt;</code></a>和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/nav" target="_blank" rel="external"><code>&lt;nav&gt;</code></a> 这些标记中的内容。 </p></blockquote><p>在显示分节时，其决定性作用的是段落的结构，而不是每个段落对应的标题的结构（因此，即使是被嵌套的section也能拥有一个<code>&lt;h1&gt;</code>标题，虽然这种做法并不推荐）。</p><h4 id="隐式分节"><a href="#隐式分节" class="headerlink" title="隐式分节"></a>隐式分节</h4><blockquote><p>HTML标题元素 (<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/h1" target="_blank" rel="external"><code>&lt;h1&gt;</code></a> 到 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/h6" target="_blank" rel="external"><code>&lt;h6&gt;</code></a>) 定义了一个新的，隐式的节段，当其不是父节段第一个标题时。这种隐式放置节段的方式通过在父节点中与之前标题的相对级别来定义。<strong>如果比之前的标题级别更低</strong>，那么在节段里开始新的隐式子节段。</p><p><strong>如果与前面标题的级别相同</strong>，那么闭合前面的节段（可能是显式标记的节段！）并开始新的同一级别的隐式节段：</p></blockquote><h3 id="分节根"><a href="#分节根" class="headerlink" title="分节根"></a>分节根</h3><blockquote><p>分节根是一个HTML元素，这个元素可以拥有自己的大纲，但是元素内部的节段和标题对其祖先的大纲没有贡献。除了文档的逻辑分节根<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/body" target="_blank" rel="external"><code>&lt;body&gt;</code></a>元素，这些元素经常在页面中引入外部内容：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/blockquote" target="_blank" rel="external"><code>&lt;blockquote&gt;</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/details" target="_blank" rel="external"><code>&lt;details&gt;</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/fieldset" target="_blank" rel="external"><code>&lt;fieldset&gt;</code></a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/figure" target="_blank" rel="external"><code>&lt;figure&gt;</code></a> 和<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/td" target="_blank" rel="external"><code>&lt;td&gt;</code></a>。</p></blockquote><h4 id="大纲之外的节段"><a href="#大纲之外的节段" class="headerlink" title="大纲之外的节段"></a>大纲之外的节段</h4><p>用于表示侧边分节元素的<code>&lt;aside&gt;</code>和导航分节元素<code>&lt;nav&gt;</code>，页眉<code>&lt;header&gt;</code>页脚<code>&lt;footer&gt;</code>不计入大纲。</p><p>即这些元素及其包含的元素不会对大纲产生任何影响。</p><h4 id="在不支持HTML5的浏览器器中使用HTML5"><a href="#在不支持HTML5的浏览器器中使用HTML5" class="headerlink" title="在不支持HTML5的浏览器器中使用HTML5"></a>在不支持HTML5的浏览器器中使用HTML5</h4><p>在不支持HTML5的IE9-浏览器中使用HTML5标签的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;!--[<span class="keyword">if</span> lt IE <span class="number">9</span>]&gt;</div><div class="line">  &lt;script&gt;</div><div class="line">    <span class="built_in">document</span>.createElement(<span class="string">"header"</span> );</div><div class="line">    <span class="built_in">document</span>.createElement(<span class="string">"footer"</span> );</div><div class="line">    <span class="built_in">document</span>.createElement(<span class="string">"section"</span>); </div><div class="line">    <span class="built_in">document</span>.createElement(<span class="string">"aside"</span>  );</div><div class="line">    <span class="built_in">document</span>.createElement(<span class="string">"nav"</span>    );</div><div class="line">    <span class="built_in">document</span>.createElement(<span class="string">"article"</span>); </div><div class="line">    <span class="built_in">document</span>.createElement(<span class="string">"hgroup"</span> ); </div><div class="line">    <span class="built_in">document</span>.createElement(<span class="string">"time"</span>   );</div><div class="line">  &lt;<span class="regexp">/script&gt;</span></div><div class="line"><span class="regexp">  &lt;noscript&gt;</span></div><div class="line"><span class="regexp">     &lt;strong&gt;Warning !&lt;/</span>strong&gt;</div><div class="line">     Because your browser does not support HTML5, some elements are simulated using JScript.</div><div class="line">     Unfortunately your browser has disabled scripting. Please enable it <span class="keyword">in</span> order to display <span class="keyword">this</span> page.</div><div class="line">  &lt;<span class="regexp">/noscript&gt;</span></div><div class="line"><span class="regexp">&lt;![endif]--&gt;</span></div></pre></td></tr></table></figure><h3 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h3><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/HTML/Sections_and_Outlines_of_an_HTML5_document" target="_blank" rel="external">HTML5的文档节段和纲要</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;HTML5大纲及计算方法&quot;&gt;&lt;a href=&quot;#HTML5大纲及计算方法&quot; class=&quot;headerlink&quot; title=&quot;HTML5大纲及计算方法&quot;&gt;&lt;/a&gt;HTML5大纲及计算方法&lt;/h1&gt;&lt;h3 id=&quot;HTML5的好处&quot;&gt;&lt;a href=&quot;#HTML5
      
    
    </summary>
    
    
      <category term="HTML5" scheme="https://fi3ework.github.io/tags/HTML5/"/>
    
  </entry>
  
  <entry>
    <title>AJAX跨域请求分析</title>
    <link href="https://fi3ework.github.io/2017-05-27/AJAX%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E5%88%86%E6%9E%90/"/>
    <id>https://fi3ework.github.io/2017-05-27/AJAX跨域请求分析/</id>
    <published>2017-05-27T13:28:11.000Z</published>
    <updated>2017-12-12T13:16:33.721Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AJAX跨域请求分析"><a href="#AJAX跨域请求分析" class="headerlink" title="AJAX跨域请求分析"></a>AJAX跨域请求分析</h2><h3 id="引出"><a href="#引出" class="headerlink" title="引出"></a>引出</h3><p>首先看一段原生调用AJAX的代码，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//原生调用AJAX</span></div><div class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line"><span class="keyword">let</span> url1 = <span class="string">"https://free-api.heweather.com/v5/now?city=beijing&amp;key=dce751438a22402b9c8c1fcb95e3ce82"</span></div><div class="line"><span class="keyword">let</span> url2 = <span class="string">"http://api.k780.com/?app=weather.future&amp;weaid=1&amp;appkey=25688&amp;sign=f1b67fe3f11c62d94d613a42f7fbd7b9&amp;format=json"</span></div><div class="line">xhr.open(<span class="string">"GET"</span>, url1, <span class="literal">true</span>);</div><div class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span> || xhr.status === <span class="number">304</span>) &#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"JSON by native:"</span>);</div><div class="line">            <span class="built_in">console</span>.log(xhr.responseText);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">xhr.send();</div></pre></td></tr></table></figure><p><code>url1</code>和<code>url2</code>两个天气的接口，<code>url1</code>来自<a href="https://www.heweather.com/documents/api/v5/now" target="_blank" rel="external">和风天气</a>，<code>url2</code>来自<a href="https://www.heweather.com/documents/api/v5/now" target="_blank" rel="external">NOWapi</a>，对<code>url1</code>的调用结果为</p><p><img src="/2017-05-27/AJAX跨域请求分析/./AJAX跨域请求分析/json1.png" alt="json1"></p><p>对url2调用的结果为</p><p><img src="/2017-05-27/AJAX跨域请求分析/./AJAX跨域请求分析/json2.png" alt="json2"></p><p>造成这两个结果不同的原因就是AJAX在调用时的同源策略，下面将进行分析。</p><h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><p>同源的反面——就是非同源，也就是跨域，首先确定跨域的定义（引自<a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy" target="_blank" rel="external">浏览器的同源策略</a>）：</p><blockquote><p>如果协议，端口（如果指定了一个）和域名对于两个页面是相同的，则两个页面具有相同的<strong>源</strong>。</p></blockquote><p>具体的大家可以看这篇文章<a href="http://twlidong.github.io/blog/2013/12/22/kua-yuan-zi-yuan-gong-xiang-cross-origin-resource-sharing-cors/" target="_blank" rel="external">跨源资源共享 Cross Origin Resource Sharing(CORS)</a>，讲的非常好了。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>从MDN的定义上来说：</p><blockquote><p> 出于安全考虑，浏览器会限制脚本中发起的跨域请求。比如，使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest" target="_blank" rel="external"><code>XMLHttpRequest</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API" target="_blank" rel="external">Fetch </a>发起的 HTTP 请求必须遵循<a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy" target="_blank" rel="external">同源策略</a>。因此，Web 应用通过 <a href="https://developer.mozilla.org/en/DOM/XMLHttpRequest" target="_blank" rel="external"><code>XMLHttpRequest</code></a> 对象或 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" target="_blank" rel="external">Fetch</a> 仅能向同域资源发起 HTTP 请求。 </p></blockquote><p>但禁止跨域访问显然限制了网站的能力，所以浏览器实现了合理的跨域请求，JS高程三：</p><blockquote><p>CORS（Cross-Origin Resource Sharing，跨源资源共享）是 W3C 的一个工作草案，定义了在必须访<br>问跨源资源时，浏览器与服务器应该如何沟通。 CORS 背后的基本思想，就是使用自定义的 HTTP 头部<br>让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。</p></blockquote><p>这个自定义的头部就是<strong>Origin字段</strong>，其中包含请求页面的源信息（协议、域名和端口），以便服务器根据这个头部信息来决定是否给予响应。</p><blockquote><p>Firefox 3.5+、 Safari 4+、 Chrome、 iOS 版 Safari 和 Android 平台中的 WebKit 都通过 XMLHttpRequest<br>对象实现了对 CORS 的原生支持。在尝试打开不同来源的资源时，无需额外编写代码就可以触发这个行<br>为。 要请求位于另一个域中的资源，使用标准的 XHR 对象并在 open()方法中传入绝对 URL 即可。</p></blockquote><p>因此，能否进行CORS通信的关键是服务器，只要服务器实现了CORS接口，就可以跨域通信。</p><p>当一个A网址的网页向B网址发送请求的时候，B的server就会根据A发出的请求的头部信息决定是否允许访问，对A的response header中会包含<code>Access-Control-Allow-Origin</code>来告诉浏览器B网址的数据是否能被A对应的域访问到（如果没有这个头部，或者有这个头部但源信息不匹配，浏览器就会驳回请求）。</p><p>默认情况下，B网址不允许跨域访问，不过B端server通过设置<code>Access-Control-Allow-Origin</code>可以允许特定的域访问。</p><p>B端的server可以设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Access-Control-Allow-Origin: http://siteA.com</div></pre></td></tr></table></figure><p>来允许A域名下的访问请求（当然也可以设为<code>*</code>，就是公共资源了，谁都可以访问）。</p><p>现代浏览器并不会完全阻止跨域请求，如果A网页向B网页发送跨域请求，浏览器还是会在网络层取得请求页面然后检查response header中有没有将A域设为允许访问的域。（有些文章中写道浏览器禁止跨域发送请求的说法其实是不正确的，无论是否跨域，浏览器都会向服务器发送请求<u>IE7及以下会阻止</u>，然后根据Response Headers来确定数据是否成功访问）。如果B端的server没有允许A域进行访问，那么浏览器将会触发<code>XMLHttpRequest</code>‘s <code>error</code>事件并阻止JS代码访问返回到数据（就像上面提到的，返回的response header中没有<code>Access-Control-Allow-Origin</code>字段）。</p><h3 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h3><p>某些请求不会触发 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS#Preflighted_requests" target="_blank" rel="external">CORS 预检请求</a>。本文称这样的请求为“简单请求”，请注意，该术语并不属于 <a href="https://fetch.spec.whatwg.org/" target="_blank" rel="external">Fetch</a> （其中定义了 CORS）规范。若请求满足所有下述条件，则该请求可视为“简单请求”：</p><ul><li>使用下列方法之一：<ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET" target="_blank" rel="external"><code>GET</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/HEAD" target="_blank" rel="external"><code>HEAD</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/POST" target="_blank" rel="external"><code>POST</code></a></li></ul></li><li>Fetch 规范定义了<a href="https://fetch.spec.whatwg.org/#cors-safelisted-request-header" target="_blank" rel="external">对 CORS 安全的首部字段集合</a>，不得人为设置该集合之外的其他首部字段。该集合为：<ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept" target="_blank" rel="external"><code>Accept</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept-Language" target="_blank" rel="external"><code>Accept-Language</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Language" target="_blank" rel="external"><code>Content-Language</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Type" target="_blank" rel="external"><code>Content-Type</code></a> （需要注意额外的限制）</li><li><code>DPR</code></li><li><code>Downlink</code></li><li><code>Save-Data</code></li><li><code>Viewport-Width</code></li><li><code>Width</code></li></ul></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Type" target="_blank" rel="external"><code>Content-Type</code></a> 的值属于下列之一：<ul><li><code>application/x-www-form-urlencoded</code></li><li><code>`multipart/form-data</code></li><li><code>text/plain</code></li></ul></li></ul><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><ol><li><p>首先客户端通过XHR向服务器发送HTTP请求，其中客户端和服务器之间使用 CORS 首部字段来处理跨域权限（如果服务器通过则允许跨域访问），即Origin字段，HTTP请求头如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">GET /v5/now?city=beijing&amp;key=dce751438a22402b9c8c1fcb95e3ce82 HTTP/1.1</div><div class="line">Host: free-api.heweather.com</div><div class="line">Connection: keep-alive</div><div class="line">Origin: null</div><div class="line">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36</div><div class="line">Accept: */*</div><div class="line">Accept-Encoding: gzip, deflate, sdch, br</div><div class="line">Accept-Language: zh-CN,zh;q=0.8</div></pre></td></tr></table></figure></li><li><p>然后是服务器进行返回，分为两种情况：</p><ol><li><p><strong>服务端允许</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Access-Control-Allow-Origin:*</div><div class="line">Connection:keep-alive</div><div class="line">Content-Length:362</div><div class="line">Content-Type:application/json;charset=UTF-8</div><div class="line">Date:Thu, 25 May 2017 15:55:41 GMT</div><div class="line">Server:nginx/1.9.10</div><div class="line">Set-Cookie:JSESSIONID=6A2D4564076C2A7AADA8F0FAF8B3BFC1; Path=/; HttpOnly</div><div class="line">Set-Cookie:bug_token=74985bfc9d79459c8916df1349e608d5; Path=/; HttpOnly</div></pre></td></tr></table></figure><p>服务端返回的 <code>Access-Control-Allow-Origin: *</code> 表明，该资源可以被<strong>任意</strong>外域访问，</p></li><li><p><strong>服务端拒绝</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Connection:keep-alive</div><div class="line">Content-Length:3317</div><div class="line">Content-Type:application/json; charset=utf-8;</div><div class="line">Date:Thu, 25 May 2017 14:58:12 GMT</div><div class="line">Server:nginx/1.10.3</div></pre></td></tr></table></figure><p>相比服务端允许的情况少了，少了如下字段（可以证明即使被拒绝，也向服务器发送了请求，只不过被服务器发了好人卡）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Access-Control-Allow-Origin:*</div><div class="line">Set-Cookie:JSESSIONID=6A2D4564076C2A7AADA8F0FAF8B3BFC1; Path=/; HttpOnly</div><div class="line">Set-Cookie:bug_token=74985bfc9d79459c8916df1349e608d5; Path=/; HttpOnly</div></pre></td></tr></table></figure><p>其中<code>Access-Control-Allow-Origin</code>参数值指定了允许访问该资源的外域 URL。url2请求失败时的错误信息<code>No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource. Origin &#39;null&#39; is therefore not allowed access.</code>就是在说request response中没有<code>Access-Control-Allow-Origin</code>这个字段，导致报错。而<code>Access-Control-Allow-Origin</code>的值为<code>*</code>或者是发送请求的域时，浏览器才允许我们拿到它页面的数据进行下一步处理。</p><h6 id="可能返回的请求"><a href="#可能返回的请求" class="headerlink" title="可能返回的请求"></a>可能返回的请求</h6><p>有三个与CORS请求相关的字段，都以<code>Access-Control-</code>开头。</p><p><strong>（1）Access-Control-Allow-Origin</strong>（必须）</p><p>该字段是必须的。它的值要么是请求时<code>Origin</code>字段的值，要么是一个<code>*</code>，表示接受任意域名的请求。</p><p><strong>（2）Access-Control-Allow-Credentials</strong>（可选）</p><p>该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为<code>true</code>，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为<code>true</code>，如果服务器不要浏览器发送Cookie，删除该字段即可。</p><p><strong>（3）Access-Control-Expose-Headers</strong>（可选）</p><p>该字段可选。CORS请求时，<code>XMLHttpRequest</code>对象的<code>getResponseHeader()</code>方法只能拿到6个基本字段：<code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code>、<code>Pragma</code>。如果想拿到其他字段，就必须在<code>Access-Control-Expose-Headers</code>里面指定。上面的例子指定，<code>getResponseHeader(&#39;FooBar&#39;)</code>可以返回<code>FooBar</code>字段的值。</p></li></ol></li></ol><h3 id="TIPS"><a href="#TIPS" class="headerlink" title="TIPS"></a>TIPS</h3><ul><li><p><strong>Q：stateReady和status有什么区别</strong>：</p><p>A：stateReady用来指示XHR请求的<em>状态</em>（比如请求还没有发送（0）， 请求完成并且已收到response（4）），stateReady是由客户端进行判断的。而status用来指示对服务器的请求是否<em>成功</em>，由服务器决定返回值。所以在进行onreadystatechange时，需要先进行判断readystate确定本地的请求已完成，再通过status去判断服务器对请求的响应。</p></li><li><p><strong>Q：为什么使用Postman可以直接跨域请求，而且浏览器必须通过JSONP才能进行跨域？</strong></p><p>A：Quoted from <a href="http://developer.chrome.com/extensions/xhr.html" target="_blank" rel="external"><em>Cross-Origin XMLHttpRequest</em></a>:</p><blockquote><p>Regular web pages can use the XMLHttpRequest object to send and receive data from remote servers, but they’re limited by the same origin policy. Extensions aren’t so limited. An extension can talk to remote servers outside of its origin, as long as it first requests cross-origin permissions.</p></blockquote></li></ul><p>  普通的网页可以用使用XHR和远程服务器发送和接收数据，可是他们需要遵循同源策略。但是拓展工具不受限制，他们只要先申请了跨域许可，就可以不受同源策略的限制与服务器进行交互。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;AJAX跨域请求分析&quot;&gt;&lt;a href=&quot;#AJAX跨域请求分析&quot; class=&quot;headerlink&quot; title=&quot;AJAX跨域请求分析&quot;&gt;&lt;/a&gt;AJAX跨域请求分析&lt;/h2&gt;&lt;h3 id=&quot;引出&quot;&gt;&lt;a href=&quot;#引出&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://fi3ework.github.io/tags/JavaScript/"/>
    
      <category term="Ajax" scheme="https://fi3ework.github.io/tags/Ajax/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript高程3笔记</title>
    <link href="https://fi3ework.github.io/2017-04-30/JavaScript%E9%AB%98%E7%A8%8B3%E7%AC%94%E8%AE%B0/"/>
    <id>https://fi3ework.github.io/2017-04-30/JavaScript高程3笔记/</id>
    <published>2017-04-30T07:35:33.000Z</published>
    <updated>2017-11-04T09:28:59.391Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Chapter1"><a href="#Chapter1" class="headerlink" title="Chapter1"></a>Chapter1</h2><h3 id="1-2"><a href="#1-2" class="headerlink" title="1.2"></a>1.2</h3><h4 id="1-2-2"><a href="#1-2-2" class="headerlink" title="1.2.2"></a>1.2.2</h4><ul><li><blockquote><p>DOM核心（DOM Core）和DOM HTML。其中，DOM核心规定的是如何映射基于XML的文档结构，以便简化对文档中任意部分的访问和操作。 DOM HTML模块则在DOM核心的基础上加以扩展，添加了针对HTML的对象和方法。</p></blockquote></li></ul><ul><li><blockquote><p>DOM2 级在原来 DOM 的基础上又扩充了（DHTML 一直都支持的）鼠标和用户界面事件、范围、遍历（迭代 DOM文档的方法）等细分模块，而且通过对象接口增加了对 CSS（Cascading Style Sheets，层叠样式表）的支持。 DOM1 级中的 DOM 核心模块也经过扩展开始支持 XML 命名空间。</p></blockquote></li><li><blockquote><p>DOM3 级则进一步扩展了 DOM，引入了以统一方式加载和保存文档的方法——在 DOM 加载和保存（DOM Load and Save）模块中定义；新增了验证文档的方法——在 DOM 验证（DOM Validation）模块中定义。 DOM3 级也对 DOM 核心进行了扩展，开始支持 XML 1.0 规范，涉及 XML Infoset、 XPath和 XML Base。</p></blockquote></li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li><blockquote><p>JavaScript 是一种专为与网页交互而设计的脚本语言，由下列三个不同的部分组成： ECMAScript，由 ECMA-262 定义，提供核心语言功能； 文档对象模型（DOM），提供访问和操作网页内容的方法和接口； 浏览器对象模型（BOM），提供与浏览器交互的方法和接口。</p></blockquote></li></ul><h2 id="Chapter2"><a href="#Chapter2" class="headerlink" title="Chapter2"></a>Chapter2</h2><h3 id="2-3"><a href="#2-3" class="headerlink" title="2.3"></a>2.3</h3><ul><li><blockquote><p>如果在文档开始处没有发现文档类型声明，则所有浏览器都会默认开启混杂模式。但采用混杂模式不是什么值得推荐的做法，因为不同浏览器在这种模式下的行为差异非常大，如果不使用某些 hack 技术，跨浏览器的行为根本就没有一致性可言。</p></blockquote></li></ul><h2 id="Chapter-3"><a href="#Chapter-3" class="headerlink" title="Chapter 3"></a>Chapter 3</h2><h3 id="3-4"><a href="#3-4" class="headerlink" title="3.4"></a>3.4</h3><ul><li><blockquote><p>只要意在保存对象的变量还没有真正保存对象，就应该明确地让该变量保存<code>null</code>值。这样做不仅可以体现<code>null</code>作为空对象指针的惯例，而且也有助于进一步区分<code>null</code>和<code>undefined</code>。</p></blockquote></li><li>由于IEEE754数值浮点计算的通病，浮点数的计算并不是完全精确的，可加一个很小的<code>EPISION</code>来控制。</li><li>事实上，只有<code>0/0</code>才会返回<code>NaN</code>，正负数除以<code>0</code>会返回对应的<code>Infinity</code></li><li><img src="/2017-04-30/JavaScript高程3笔记/number.png" alt="number"></li><li><blockquote><p>在对非数值应用一元加操作符时，该操作符会像 Number()转型函数一样对这个值执行转换。</p></blockquote></li><li><blockquote><p>这个属性返回的字符数包括 16 位字符的数目。如果字符串中包含双字节字符，那么 length 属性可能不会精确地返回字符串中的字符数目。</p></blockquote></li></ul><p><code>.lenghth</code>会将单双字节字符都算作一个字符对待，英文和符号属于单字节字符，汉字等属于双字符字节，可以通过<code>&quot;abc&quot;.replace( /[^\x00-\xff]/g,&quot;aa&quot; ).length</code>匹配双字节，计算正确的length(要声明<code>&lt;meta charset=&quot;UTF-8&quot;&gt;</code>，否则结果会比较奇怪)。</p><ul><li><code>null</code>和<code>undefined</code>没有<code>toString()</code>, 在不知道要转换的是否为<code>null</code>或<code>undefined</code>时,可以使用<code>String()</code>转换函数,如果为<code>null</code>或<code>undefined</code>,会输出<code>&quot;null&quot;</code>和”<code>undefined&quot;</code>,否则调用对象的<code>toString()</code>方法.</li></ul><h3 id="3-5"><a href="#3-5" class="headerlink" title="3.5"></a>3.5</h3><ul><li><blockquote><p>按位非操作的本质:操作数的负数减1</p></blockquote></li><li><code>&gt;&gt;&gt;</code>无符号右移的操作数如果是负数,会变成正数,而且往往比较大.因为负数以其绝对值的二进制的补码表示.</li><li><code>&amp;&amp;</code><ul><li>如果第一个操作数是对象,则返回第二个操作数</li><li>如果第一个操作数为<code>true</code>,且第二个操作数是对象,则返回第二个对象.</li><li>如果都是对象,则返回第二个.</li><li>如果有个操作数是<code>null</code> <code>undefined</code> <code>NaN</code>则返回<code>null</code> <code>undefined</code> <code>NaN</code>.</li><li><strong>如果第一个操作数的求值结果为<code>true</code>，则返回第二个操作数</strong></li></ul></li><li><code>||</code><ul><li>如果第一个操作数是对象,则返回第一个</li><li><strong>如果第一个操作数的求值结果为<code>false</code>，则返回第二个操作数</strong></li><li>如果两个操作数都是对象,则返回第一个</li><li>如果两个操作数都是<code>null</code> <code>undefined</code> <code>NaN</code>则返回<code>null</code> <code>undefined</code> <code>NaN</code>.</li><li>逻辑或可以用来避免为变量赋<code>null</code>或<code>undefined</code>, 比如<code>var obj = preferredObj || backupObj</code></li></ul></li><li><p>​</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="literal">Infinity</span> * <span class="number">-5</span> = - <span class="literal">Infinity</span>;</div><div class="line"><span class="literal">Infinity</span> * <span class="number">0</span> = <span class="literal">NaN</span>;</div><div class="line"><span class="literal">Infinity</span> / <span class="literal">Infinity</span> = <span class="literal">NaN</span>;</div><div class="line"><span class="number">0</span> / <span class="number">0</span> = <span class="literal">NaN</span>;</div><div class="line"><span class="number">5</span> / <span class="number">0</span> = <span class="literal">Infinity</span>; </div><div class="line"><span class="number">3</span> / <span class="literal">Infinity</span> = <span class="number">0</span>;</div><div class="line"><span class="literal">Infinity</span> / <span class="number">0</span> = <span class="literal">Infinity</span>;</div></pre></td></tr></table></figure></li><li><p>​</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">5</span> % <span class="literal">Infinity</span> = <span class="literal">NaN</span>;</div><div class="line"><span class="number">0</span> % <span class="literal">Infinity</span> = <span class="literal">NaN</span>;</div><div class="line"><span class="literal">Infinity</span> % <span class="literal">Infinity</span> = <span class="literal">NaN</span>;</div><div class="line"><span class="number">5</span> % <span class="number">0</span> = <span class="number">0</span>;</div></pre></td></tr></table></figure></li><li><p>​</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="literal">Infinity</span> - <span class="literal">Infinity</span> = <span class="literal">NaN</span>;</div><div class="line">+<span class="number">0</span> - <span class="number">0</span> = +<span class="number">0</span>;</div><div class="line"><span class="number">-0</span> - (<span class="number">-0</span>) = +<span class="number">0</span>;</div></pre></td></tr></table></figure></li><li><p><code>+</code>: </p><blockquote><p>如果有一个操作数是对象、数值或布尔值，则调用它们的<code>toString()</code>方法取得相应的字符串值，然后再应用前面关于字符串的规则。对于<code>undefined</code>和<code>null</code>，则分别调用<code>String()</code>函数并取得字符串<code>&quot;undefined&quot;</code>和<code>&quot;null&quot;</code>。</p></blockquote></li><li><code>-</code>: <blockquote><p>如果有一个操作数是对象，则调用对象的<code>valueOf()</code>方法以取得表示该对象的数值。如果得到的值是<code>NaN</code>，则减法的结果就是<code>NaN</code>。如果对象没有<code>valueOf()</code>方法，则调用其<code>toString()</code>方法并将得到的字符串转换为数值。</p></blockquote></li><li><code>&gt;</code> <code>&lt;</code> <code>&gt;=</code> <code>&lt;=</code><blockquote><p>如果两个操作数都是字符串，则比较两个字符串对应的字符编码值。<br>如果一个操作数是数值，则将另一个操作数转换为一个数值，然后执行数值比较。<br>如果一个操作数是对象，则调用这个对象的<code>valueOf()</code>方法，用得到的结果按照前面的规则执行比较。如果对象没有<code>valueOf()</code>方法，则调用<code>toString()</code>方法，并用得到的结果根据前面的规则执行比较。<br>如果一个操作数是布尔值，则先将其转换为数值，然后再执行比较。<br>任何操作数与<code>NaN</code>进行关系比较，结果都是<code>false</code>。</p></blockquote></li><li><code>==</code><blockquote><p>如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值；<br>如果一个操作数是对象，另一个操作数不是，则调用对象的 valueOf()方法，用得到的基本类型值按照前面的规则进行比较；<br><code>null</code>和<code>undefined</code>是相等的。<br> 要比较相等性之前，不能将<code>null</code>和<code>undefined</code>转换成其他任何值。<br>由于相等和不相等操作符存在类型转换问题，而为了保持代码中数据类型的完整性，我们推荐使用全等和不全等操作符。</p></blockquote></li><li>ES5之前<code>for in</code>遇到<code>null</code>或<code>undefined</code>会报错,ES5修正了这个错误,如果需要兼容.先检测确认该对象的值不是<code>null</code>或<code>undefined</code>。</li><li><blockquote><p>由于大量使用<code>with</code>语句会导致性能下降，同时也会给调试代码造成困难，因此在开发大型应用程序时，不建议使用<code>with</code>语句。</p></blockquote></li><li>在使用<code>switch</code>时的<code>case</code>可以为表达式或各种类型不同的数据.</li><li><blockquote><p><code>return</code>语句也可以不带有任何返回值。在这种情况下，函数在停止执行后将返回 <code>undefined</code>值。建议要么始终返回一个值,要么就直接<code>return</code>.</p></blockquote></li><li><code>arguments</code>和参数的值时刻保持同步,修改其中一个就会同步另一个,如果传入的是对象,他们占用的其实还是同一片内存空间. </li><li><code>arguments</code>数组的长度是由传入的参数的个数决定的,所以如果只传入一个参数,但是修改<code>arguments[1]</code>也只会修改一个不存在的值,<code>arguments</code>的长度像<code>array</code>一样可以随意修改.</li><li>在严格模式下,对<code>arguments</code>的修改不会再同步到参数上,反过来也不会同步.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a1, a2, a3</span>)</span>&#123;</div><div class="line"><span class="built_in">console</span>.log(a2); <span class="comment">//5</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">1</span>]); <span class="comment">//5</span></div><div class="line">a2 = <span class="number">99</span>;</div><div class="line"><span class="built_in">console</span>.log(a2); <span class="comment">//99</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">1</span>]); <span class="comment">//5</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">test(<span class="number">3</span>, <span class="number">5</span>);</div></pre></td></tr></table></figure></li></ul><h2 id="Chapter-4"><a href="#Chapter-4" class="headerlink" title="Chapter 4"></a>Chapter 4</h2><h3 id="4-1"><a href="#4-1" class="headerlink" title="4.1"></a>4.1</h3><ul><li><blockquote><p>ECMAScript 中所有函数的参数都是按值传递的。  </p></blockquote></li></ul><p>先看两个例子<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> animals = &#123;</div><div class="line">mammals : &#123;</div><div class="line">dog : <span class="number">1</span>,</div><div class="line">cat : <span class="number">2</span></div><div class="line">&#125;,</div><div class="line">others : <span class="string">"999"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeAnimal</span>(<span class="params">obj</span>)</span>&#123;</div><div class="line">obj.mammals = <span class="string">"no mammals"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">changeAnimal(animals);</div><div class="line"><span class="built_in">console</span>.log(animals.mammals);<span class="comment">//no mammals</span></div></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> animals = &#123;</div><div class="line">mammals: &#123;</div><div class="line">dog: <span class="number">1</span>,</div><div class="line">cat: <span class="number">2</span></div><div class="line">&#125;,</div><div class="line">others: <span class="string">"999"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeAnimal</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">obj = &#123;</div><div class="line">mammals: &#123;</div><div class="line">rabbit : <span class="number">3</span>,</div><div class="line">pig: <span class="number">4</span></div><div class="line">&#125;,</div><div class="line">others: <span class="string">"666"</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">changeAnimal(animals);</div><div class="line"><span class="built_in">console</span>.log(animals.mammals);<span class="comment">//Object &#123;dog: 1, cat: 2&#125;</span></div></pre></td></tr></table></figure><p>怎么理解按值传递,可以将其理解为C++的指针,相当于<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Animal* animals = <span class="keyword">new</span> Animals()</div></pre></td></tr></table></figure></p><p>我们平时操作的都是这个指针对象.当函数传递一个对象的时候,实际上传递的是一个指针对象的深拷贝,两个指针占用内存独立,但指向同一块内存的对象.</p><p>在上面的第一个例子中,传入的<code>obj</code>参数是新建立的指向<code>animals</code>的指针,对其进行的操作相当于C++中的<code>obj-&gt;mammals =</code>,所以成功的修改了<code>animals</code>的值.<br>在第二个例子中,进入<code>changeAnimal</code>函数,<code>obj</code>依旧是新建立的指向<code>animals</code>的指针,但是随后的操作其实是将<code>obj</code>指向了新生成的匿名对象,相当于<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeAnimal</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line"><span class="keyword">var</span> newAnimal = &#123;</div><div class="line">mammals: &#123;</div><div class="line">rabbit : <span class="number">3</span>,</div><div class="line">pig: <span class="number">4</span></div><div class="line">&#125;,</div><div class="line">others: <span class="string">"666"</span></div><div class="line">&#125;</div><div class="line">obj = newAnimal;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>最后一句<code>obj = newAnimal</code>, 其实就是两个指针之间的赋值了,<code>newAnimal</code>是指向<code>newAnimal</code>对象的指针,将它赋值给了<code>obj</code>,<code>obj</code>就是指向新的对象了,<code>obj</code>所指的<code>animals</code>还没有被动过,但<code>obj</code>从此切断了与原来的<code>animals</code>的关系,在离开这个函数作用域的时候,<code>newAnimal</code>连同<code>obj</code>会被一起回收掉.</p><ul><li><blockquote><p>垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。</p></blockquote></li><li><p>IE9的<code>BOM</code>和<code>DOM</code>中的对象其实都是以<code>COM</code>对象的形式来实现的,而<code>COM</code>使用的是引用计数,所以如果<code>COM</code>发生了循环引用,需要使用<code>=null</code>切断引用.</p></li><li><blockquote><p>解除一个值的引用并不意味着自动回收该值所占用的内存。解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。</p></blockquote></li></ul><h2 id="Chapter-5"><a href="#Chapter-5" class="headerlink" title="Chapter 5"></a>Chapter 5</h2><h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><ul><li>使用<code>istanceof Array</code>会在网页中存在多个框架时出现问题,如果有多个框架,则有多个全局执行环境,则有多个<code>Array</code>的构造函数.当一个数组从一个框架传入另一个框架,再调用<code>istanceof</code>则不会是另一个框架的构造函数.ES5加入了<code>Array.isArray()</code>用来检测是否为<code>Array</code>.</li><li>数组的<code>toString()</code>会返回<code>,</code>分割的字符串,其中每一项分别调用了<code>toString()</code>,至于<code>valueOf()</code>,则返回原字符串.</li><li><code>sort</code>的<code>cmp</code>函数规则:如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则返回 <code>0</code>，如果第一个参数应该位于第二个之后则返回一个正数。</li><li>不给<code>concat()</code>输入参数可以快速的复制一个数组.</li><li><code>Array.indexOf()</code>和<code>Array.lastIndexOf()</code>在比较时使用的是<code>===</code></li><li><code>Array.reduce()</code>和<code>Array.reduceRight()</code>从第二(倒数第二)项开始.</li></ul><h3 id="Reg"><a href="#Reg" class="headerlink" title="Reg"></a>Reg</h3><ul><li><p>全局匹配<code>g</code>的时候,每次匹配会依次匹配所有的匹配项,当没有时,返回<code>null</code>再从头开始.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> reg2 = <span class="regexp">/.a/g</span>;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">  <span class="keyword">var</span> out = reg1.exec(<span class="string">"catastropathae"</span>);</div><div class="line">  <span class="built_in">console</span>.log(out)</div><div class="line">&#125;</div><div class="line"></div><div class="line">test.html:<span class="number">14</span> [<span class="string">"ca"</span>, <span class="attr">index</span>: <span class="number">0</span>, <span class="attr">input</span>: <span class="string">"catastropathae"</span>]</div><div class="line">test.html:<span class="number">14</span> [<span class="string">"ta"</span>, <span class="attr">index</span>: <span class="number">2</span>, <span class="attr">input</span>: <span class="string">"catastropathae"</span>]</div><div class="line">test.html:<span class="number">14</span> [<span class="string">"pa"</span>, <span class="attr">index</span>: <span class="number">8</span>, <span class="attr">input</span>: <span class="string">"catastropathae"</span>]</div><div class="line">test.html:<span class="number">14</span> [<span class="string">"ha"</span>, <span class="attr">index</span>: <span class="number">11</span>, <span class="attr">input</span>: <span class="string">"catastropathae"</span>]</div><div class="line">test.html:<span class="number">14</span> <span class="literal">null</span></div><div class="line">test.html:<span class="number">14</span> [<span class="string">"ca"</span>, <span class="attr">index</span>: <span class="number">0</span>, <span class="attr">input</span>: <span class="string">"catastropathae"</span>]</div><div class="line">test.html:<span class="number">14</span> [<span class="string">"ta"</span>, <span class="attr">index</span>: <span class="number">2</span>, <span class="attr">input</span>: <span class="string">"catastropathae"</span>]</div><div class="line">test.html:<span class="number">14</span> [<span class="string">"pa"</span>, <span class="attr">index</span>: <span class="number">8</span>, <span class="attr">input</span>: <span class="string">"catastropathae"</span>]</div><div class="line">test.html:<span class="number">14</span> [<span class="string">"ha"</span>, <span class="attr">index</span>: <span class="number">11</span>, <span class="attr">input</span>: <span class="string">"catastropathae"</span>]</div><div class="line">test.html:<span class="number">14</span> <span class="literal">null</span></div><div class="line">test.html:<span class="number">20</span> [<span class="string">"ca"</span>, <span class="attr">index</span>: <span class="number">0</span>, <span class="attr">input</span>: <span class="string">"catastropathae"</span>]</div></pre></td></tr></table></figure></li><li><p><code>toString()</code>和<code>toLocaleString()</code>都会返回正则表达式的字面量,与创建正则表达式的方式无关.<code>valueOf()</code>返回正则表达式自身.</p></li><li>使用<code>Reg.$1 - Reg.$9</code>可以访问存储的捕获组,这样即使<code>.test()</code>只返回布尔值,也可以获得捕获组.</li></ul><h3 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h3><ul><li><blockquote><p>函数是对象,函数名是指针,可以用<code>null</code>切断他们之间的联系.</p></blockquote></li><li>函数中有<code>arguments.callee</code>指向这个函数本身,可以应用在递归函数中,在严格模式下无法访问.</li><li><code>arguments.callee.caller</code>可以显示调用当前函数的函数的引用,在严格模式下无法访问.</li><li><code>toString()</code> <code>toLocaleString()</code> <code>valueOf()</code>都返回函数的代码.</li></ul><h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><ul><li>在对基本类型进行处理的时候,会隐式创建一个<code>String</code>,在处理完之后再立即销毁(指向<code>null</code>).所以其生命周期不可控.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s1 = <span class="string">"sss"</span>;</div><div class="line">s1.name = <span class="string">"sssName"</span>;</div><div class="line"><span class="built_in">console</span>.log(s1.name);<span class="comment">//undefined</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> s2 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"ssss"</span>);</div><div class="line">s2.name = <span class="string">"ssssName"</span>;</div><div class="line"><span class="built_in">console</span>.log(s2.name);<span class="comment">//ssssName</span></div></pre></td></tr></table></figure></li></ul><h4 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h4><ul><li>不建议使用,<code>Boolean</code>对象的实例是对象,但是对象的布尔运算都是<code>true</code>.</li></ul><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><ul><li><blockquote><p><code>toFixed()</code>方法会按照指定的小数位返回数值的字符串表示.</p></blockquote></li><li><blockquote><p>可用于格式化数值的方法是<code>toExponential()</code>，该方法返回以指数表示法（也称 e 表示法）</p></blockquote></li><li><blockquote><p><code>toPrecision()</code>方法可能会返回固定大小（fixed）格式，也可能返回指数<br>（exponential）格式；具体规则是看哪种格式最合适。</p></blockquote></li><li><code>charCodeAt()</code>用来访问某个字符的ASCII码</li><li><code>replace()</code>的第二个参数可以是一个函数,参数依次是模式的匹配项,模式匹配项在字符串中的位置和原始字符串.返回一个字符串作为要替换的字符串.</li><li><code>split()</code>的第一个参数可以使正则表达式.</li><li><code>localeCompare()</code>返回的值取决于实现,所以在使用前应当确认好.</li><li><code>String.fromeCharCode()</code>将ASCII码转为字符串.</li></ul><h3 id="5-7"><a href="#5-7" class="headerlink" title="5.7"></a>5.7</h3><ul><li><code>encodeURI()</code>不会对本身属于URI的特殊字符进行编码,<code>encodeURIComponent()</code>则会对它发现的任何非标准字符进行编码.相反的操作是<code>decodeURI()</code>和<code>decodeURIComponent()</code></li><li>比如取1-10的整数,值 = <code>Math.floor(Math.random()</code> * <code>可能值的总数</code> + <code>第一个可能的值</code>.</li></ul><h2 id="Chapter-6"><a href="#Chapter-6" class="headerlink" title="Chapter 6"></a>Chapter 6</h2><h3 id="6-1"><a href="#6-1" class="headerlink" title="6.1"></a>6.1</h3><ul><li><blockquote><p>在调用<code>Object.defineProperty()</code>方法时，如果不指定，<code>configurable</code>、 <code>enumerable</code>和<code>writable</code>特性的默认值都是<code>false</code>。</p></blockquote></li><li><blockquote><p>一旦把属性定义为不可配置的，就不能再把它变回可配置了。此时，再调用<code>Object.defineProperty()</code>方法修改除 <code>writable</code>之外的特性，都会导致错误.</p></blockquote></li></ul><p>书上是这么写的,但事实真的是这样吗?<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj1 = &#123;</div><div class="line">  name: <span class="string">"111"</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.defineProperty(obj1, <span class="string">"name"</span>, &#123;</div><div class="line">  configurable: <span class="literal">false</span>,</div><div class="line">  writable: <span class="literal">true</span>,</div><div class="line">&#125;)</div><div class="line"></div><div class="line">obj1.name = <span class="string">"222"</span>;</div><div class="line"><span class="built_in">console</span>.log(obj1.name)<span class="comment">//222</span></div><div class="line"></div><div class="line"><span class="built_in">Object</span>.defineProperty(obj1, <span class="string">"name"</span>, &#123;</div><div class="line">  writable: <span class="literal">false</span>,</div><div class="line">&#125;)</div><div class="line">obj1.name = <span class="string">"333"</span>;</div><div class="line"><span class="built_in">console</span>.log(obj1.name)<span class="comment">//22</span></div></pre></td></tr></table></figure></p><p>可以看到,再<code>Configurable</code>被设置为<code>false</code>的情况下,可以将<code>writable</code>由<code>true</code>改为<code>false</code>,但是<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj1 = &#123;</div><div class="line">  name: <span class="string">"111"</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.defineProperty(obj1, <span class="string">"name"</span>, &#123;</div><div class="line">  configurable: <span class="literal">false</span>,</div><div class="line">  writable: <span class="literal">false</span>,</div><div class="line">&#125;)</div><div class="line"></div><div class="line">obj1.name = <span class="string">"222"</span>;</div><div class="line"><span class="built_in">console</span>.log(obj1.name)<span class="comment">//111</span></div><div class="line"></div><div class="line"><span class="built_in">Object</span>.defineProperty(obj1, <span class="string">"name"</span>, &#123;</div><div class="line">  writable: <span class="literal">true</span>,</div><div class="line">&#125;)</div><div class="line">obj1.name = <span class="string">"333"</span>;</div><div class="line"><span class="built_in">console</span>.log(obj1.name)<span class="comment">//test.html:24 Uncaught TypeError: Cannot redefine property: name</span></div></pre></td></tr></table></figure></p><p>却不能将<code>false</code>改为<code>true</code>,说明一但将<code>Configurable</code>属性设置为<code>false</code>之后,只能将属性的可配置属性往低改.另外,如果<code>Configurable</code>属性设置为<code>false</code>时改写<code>enumerable</code> <code>Writable</code>属性,如果改写前后同为<code>false</code>或同为<code>true</code>或者之前提到的将<code>Writable</code>由<code>true</code>变为<code>false</code>,则不会报错,否则会报错.</p><h3 id="6-2"><a href="#6-2" class="headerlink" title="6.2"></a>6.2</h3><ul><li><p>通过构造函数创建一个实例的过程要经过四个步骤:</p><blockquote><ol><li>创建一个新对象；</li><li>将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象）；</li><li>执行构造函数中的代码（为这个新对象添加属性）；</li><li>返回新对象。</li></ol></blockquote></li><li><p>可以使用形如<code>var obj = {}; Person.call(obj);</code>来执行构造函数,因为<code>call</code>和<code>apply</code>的本质就是设置函数体内<code>this</code>的值.</p></li><li><blockquote><p>无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个 <code>prototype</code>属性，这个属性指向函数的原型对象。在默认情况下，所有原型对象都会自动获得一个<code>constructor</code>（构造函数）属性，这个属性包含一个指向<code>prototype</code>属性所在函数的指针。</p></blockquote></li><li><blockquote><p>ECMAScript 5 的<code>Object.getOwnPropertyDescriptor()</code>方法只能用于实例属性，要取得原型属性的描述符，必须直接在原型对象上调用<code>Object.getOwnPropertyDescriptor()</code>方法。</p></blockquote></li></ul><p>所以是说使用<code>getOwnPropertyDescriptor()</code>只能获得当前实例的属性,不能访问继承而来的属性.</p><ul><li><code>in</code>操作符可以返回对象是否具有某个属性,无论这个属性是实例具有的还是继承自原型,配合<code>hasOwnProperty()</code>可以判断属性是来自原型还是自有.</li><li><blockquote><p> 要取得对象上所有可枚举的<strong>实例</strong>属性，可以使用ECMAScript 5 的<code>Object.keys()</code>方法。这个方法接收一个对象作为参数，返回一个包含所有<strong>可枚举属性</strong>的字符串数组。</p></blockquote></li><li><blockquote><p>如果你想要得到所有实例属性，无论它是否可枚举，都可以使用 <code>Object.getOwnPropertyNames()</code>方法。</p></blockquote></li><li><code>instanceof</code>运算符用来判断一个构造函数的<code>prototype</code>属性所指向的对象是否存在另外一个要检测对象的原型链上,所以即使将<code>obj.constructor.prototype</code>重写,导致<code>prototype</code>的<code>constructor</code>不再指向构造函数,<code>instanceof</code>也可以正确的指示.</li><li>直接重写<code>prototype</code>会导致原本不可枚举的<code>constructor</code>属性变得可以枚举,可以在最后使用<code>Object.defineProperty()</code>来定义一个不可枚举的<code>constructor</code>.</li><li><blockquote><p>当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部<br>属性），指向构造函数的原型对象。 即<code>[[Prototype]]</code></p></blockquote></li></ul><p>所以,在重写原型对象之后,老的实例所指向的原型对象仍然是老的原型对象,而不是新的.是不会动态更新的.</p><ul><li>寄生构造和稳妥寄生构造的区别就是,稳妥寄生构造创建的实例只有方法而没有属性,稳妥寄生构造的属性是通过定义在构造函数内部,通过闭包进行访问的.稳妥构造函数模式提供的这种安全性，使得它非常适合在某些安全执行环境下使用.<h3 id="6-3"><a href="#6-3" class="headerlink" title="6.3"></a>6.3</h3></li><li>借用构造函数<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">//继承了 SuperType，同时还传递了参数</span></div><div class="line">  SuperType.call(<span class="keyword">this</span>, <span class="string">"Nicholas"</span>);</div><div class="line">  <span class="comment">//实例属性</span></div><div class="line">  <span class="keyword">this</span>.age = <span class="number">29</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> sub1 = <span class="keyword">new</span> SubType();</div><div class="line"><span class="built_in">console</span>.log(sub1 <span class="keyword">instanceof</span> SubType);<span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(sub1 <span class="keyword">instanceof</span> SuperType);<span class="comment">//false</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(sub1) == SubType.prototype);<span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(<span class="built_in">Object</span>.getPrototypeOf(sub1)) == <span class="built_in">Object</span>.prototype);<span class="comment">//true</span></div></pre></td></tr></table></figure></li></ul><p>可以看出<code>SuperType</code>已经不在<code>sub1</code>的原型链上了,所以<code>SubType</code>的实例只能调用<code>SuperType</code>构造函数中的方法,而无法继承<code>SuperType</code>的原型属性.</p><h2 id="Chapter-7"><a href="#Chapter-7" class="headerlink" title="Chapter 7"></a>Chapter 7</h2><h3 id="7-2"><a href="#7-2" class="headerlink" title="7.2"></a>7.2</h3><ul><li><blockquote><p>作用域链本质上是一个指向变量对象的指针列表，它只引用但不实际包含变量对象.</p></blockquote></li></ul><p>在<strong>创建</strong>局部函数时,会创建一个预先包含全局变量的作用域链,然后将这个作用域链保存在<strong>内部的<code>[[Scope]]</code>属性中</strong>.当<strong>调用</strong>局部函数时,会为函数创建一个执行环境,然后通过<strong>复制</strong>函数的<code>[[Scope]]</code>属性中的对象构建起<strong>执行环境的作用域链</strong>.此后,当有新的变量对象被创建会被推入<strong>执行环境作用域链的前端</strong>.</p><ul><li>闭包之所以能持续引用外部函数的变量,是因为闭包函数的作用域链中还在持续引用外部函数的活动对象.所以,此时外部函数的<strong>作用域链已经被销毁了</strong>,但活动对象扔能停留在内存中.</li><li>还是使用<code>null</code>接触对闭包的引用~</li><li><blockquote><p>JavaScript从来不会告诉你是否多次声明了同一个变量；遇到这种情况，它只会对后续的声明视而不见（不过，它会执行后续声明中的变量初始化）。</p></blockquote></li><li>使用立即执行函数可以模仿块级作用域,好处是因为没有指向匿名函数的引用.只要函数执行完毕,就可以立即销毁其作用域链了.</li></ul><h2 id="Chapter-10"><a href="#Chapter-10" class="headerlink" title="Chapter 10"></a>Chapter 10</h2><h3 id="10-1"><a href="#10-1" class="headerlink" title="10.1"></a>10.1</h3><ul><li>IE没有实现<code>Node</code>类型,所以无法通过访问类似<code>Node.ELEMENT_NODE</code>的常量来判断节点的类型,最好是用数字.<h4 id="Node对象的方法"><a href="#Node对象的方法" class="headerlink" title="Node对象的方法:"></a><code>Node</code>对象的方法:</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">hasChildNodes() <span class="comment">//是否包含子节点</span></div><div class="line">ownDocument() <span class="comment">//指向文档的文档节点</span></div><div class="line">appendChild() <span class="comment">//如果节点已经存在于文档当中了,那么会将节点移动到新的位置</span></div><div class="line">replaceChild() <span class="comment">//替换节点,但被替换的节点还存留于文档中,只是没在文档树中</span></div><div class="line">removeChild() <span class="comment">//删除节点,被删节点同上</span></div><div class="line">cloneChild() <span class="comment">//接受一个参数,true为深复制,false为浅复制.这个方法不会复制节点上的事件,但在IE中会</span></div><div class="line">normalize() <span class="comment">//合并后代的相邻文本节点和删除空白文本节点</span></div></pre></td></tr></table></figure></li></ul><h5 id="Document对象的方法"><a href="#Document对象的方法" class="headerlink" title="Document对象的方法:"></a><code>Document</code>对象的方法:</h5><ul><li><blockquote><p><code>domain</code>: 如果域名一开始是“松散的”（loose），那么不能将它再设置为“紧绷的”（tight）</p></blockquote></li><li><code>HTMLCollection</code>对象有一个方法:<code>namedItem()</code>用来根据<code>name</code>获取对象,但与<code>getElementByName</code>不同的是,它只会返回第一个<code>name</code>符合要求的节点.</li><li>在IE中<code>getElementsByTagName()</code>会包含所有注释节点.</li><li><p>​</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">document</span>.anchors <span class="comment">//所有带name特性的&lt;a&gt;元素</span></div><div class="line"><span class="built_in">document</span>.applets <span class="comment">//所有&lt;applet&gt;元素,没用过这个标签,一脸懵逼</span></div><div class="line"><span class="built_in">document</span>.forms <span class="comment">//所有表单</span></div><div class="line"><span class="built_in">document</span>.images <span class="comment">//所有img元素</span></div><div class="line"><span class="built_in">document</span>.links <span class="comment">//所有得href特性的&lt;a&gt;元素</span></div></pre></td></tr></table></figure></li><li><blockquote><p>我们建议多数情况下，在使用DOM的某些特殊的功能之前，最好除了检测<code>hasFeature()</code>之外，还同时使用能力检测。</p></blockquote></li></ul><h5 id="Element类型"><a href="#Element类型" class="headerlink" title="Element类型:"></a><code>Element</code>类型:</h5><ul><li>在HTML中,标签名都是大写表示,再XML中标签名会与源码保持一致.所以最好在进行标签比较之前统一大小写.ex:<code>element.tagName.toLowerCase() == &quot;p&quot;</code></li><li><blockquote><p>特性的名称是不区分大小写的，即”ID”和”id”代表的都是同一个特性。另外也要注意，根据 HTML5 规范，自定义特性应该加上<code>data-</code>前缀以便验证。</p></blockquote></li><li><blockquote><p><code>Element</code>类型的<code>attributes</code>属性包含该节点所有的属性.</p></blockquote></li><li><code>Element</code>元素也支持<code>getElementsByTagName</code>这个方法.</li></ul><h5 id="Text类型"><a href="#Text类型" class="headerlink" title="Text类型:"></a><code>Text</code>类型:</h5><ul><li><code>Text</code>类型的<code>nodeValue</code>和<code>data</code>属性是等价的.</li><li><blockquote><p><code>appendData(text)</code>：将<code>text</code>添加到节点的末尾。</p></blockquote></li><li><blockquote><p><code>deleteData(offset, count)</code>：从<code>offset</code>指定的位置开始删除<code>count</code>个字符。</p></blockquote></li><li><blockquote><p><code>insertData(offset, text)</code>：在<code>offset</code>指定的位置插入<code>text</code>。</p></blockquote></li><li><blockquote><p><code>replaceData(offset, count, text)</code>：用<code>text</code>替换从<code>offset</code>指定的位置开始到<code>offset+count</code>为止处的文本。</p></blockquote></li><li><blockquote><p><code>splitText(offset)</code>：从<code>offset</code>指定的位置将当前文本节点分成两个文本节点。</p></blockquote></li><li><blockquote><p><code>substringData(offset, count)</code>：提取从<code>offset</code>指定的位置开始到<code>offset+count</code>为止处的字符串。</p></blockquote></li></ul><h5 id="Comment类型"><a href="#Comment类型" class="headerlink" title="Comment类型"></a><code>Comment</code>类型</h5><ul><li><blockquote><p><code>Comment</code>类型与<code>Text</code>类型继承自相同的基类，因此它拥有除<code>splitText()</code>之外的所有字符串操作方法。</p></blockquote></li><li><blockquote><p>另外，使用<code>document.createComment()</code>并为其传递注释文本也可以创建注释节点</p></blockquote></li></ul><h2 id="Chapter-11"><a href="#Chapter-11" class="headerlink" title="Chapter 11"></a>Chapter 11</h2><h3 id="11-1"><a href="#11-1" class="headerlink" title="11.1"></a>11.1</h3><ul><li><blockquote><p><code>querySelectorAll()</code>返回的值实际上是带有所有属性和方法的<code>NodeList</code>，而其底层实现则类似于一组元素的快照，而非不断对文档进行搜索的动态查询。</p><h3 id="11-3"><a href="#11-3" class="headerlink" title="11.3"></a>11.3</h3></blockquote></li><li><code>getElementsByClassName()</code>可以传递多个类名,使用空格分割,<code>Element</code>和<code>Document</code>都有这个方法.</li><li><code>classList</code>是<code>DomTokenList</code>的实例,有个<code>contains(value)</code>的属性,返回是否具有对应的类名.支持<code>classList</code>的浏览器是Firefox3.6+和Chrome.</li><li><code>document.activeElement</code>能返回DOM中获得焦点的元素的引用.文档刚加载完毕时<code>document.activeElement</code>指向<code>document.body</code></li><li><code>document.readyState</code>用来指示文档是否已经加载完毕.</li><li><code>document.compatMode</code>用来检测IE是在混杂模式还是在标准模式.</li><li>与<code>document.body</code>相对应的也有<code>document.head</code>属性.</li><li><code>document.charset</code>可以用来指定字符集.</li><li>通过在标签中添加<code>data-</code>开头的属性,就可以在元素的<code>dataset</code>属性中获得对应的属性(不包含<code>data-</code>前缀)</li><li><blockquote><p>不要指望所有浏览器返回的 innerHTML 值完全相同。</p></blockquote></li><li><code>insertAdjacentHTML()</code>可以像<code>innerHTML</code>一样插入HTML文本,第一个参数可以为以下之一<code>beforebegin</code> <code>afterbegin</code> <code>beforeend</code> <code>afterend</code></li><li>使用<code>innerHTML</code> <code>outerHTML</code> <code>insertAdjacentHTML</code>方法时,元素与对应的js事件的绑定关系并没有一并删除.</li><li>设置<code>innerHTML</code>或<code>outerHTML</code> 时，就会创建一个HTML解析器,所以过多次的调用会造成多次的创建和销毁HTML解析器,带来性能损失.</li><li><code>contains()</code>检测参数DOM是否为调用方法的DOM的子节点.相当于<code>compareDocumentPosition()</code></li><li><code>innerText</code>永远只会生成当前节点的一个文本节点,会对输入的HTML进行编码.利用这一点，可以通过<code>innerText</code>属性过滤掉HTML标签。方法是将<code>innerText</code>设置为等于 <code>innerText</code>，这样就可以去掉所有 HTML 标签.</li></ul><h2 id="Chapter-12"><a href="#Chapter-12" class="headerlink" title="Chapter 12"></a>Chapter 12</h2><h3 id="12-2"><a href="#12-2" class="headerlink" title="12.2"></a>12.2</h3><ul><li>使用<code>ele.style.cssText</code>是最快捷的方法,因为一次能设置多种样式.</li><li>使用<code>ele.getPropertyValue(prop)</code>可以得到特定内联样式的值.</li><li>最常用来确定浏览器视口大小的方法是<code>document.documentElement.clientWidth</code>.</li><li>通过<code>scrollLeft</code>和<code>scrollTop</code>既可以确定元素当前滚动的状态,也可以设置元素的滚动位置</li></ul><h2 id="Chapter-13"><a href="#Chapter-13" class="headerlink" title="Chapter 13"></a>Chapter 13</h2><h3 id="13-1"><a href="#13-1" class="headerlink" title="13.1"></a>13.1</h3><ul><li><p>通过<code>addEventListener()</code>添加的事件处理程序只能使用<code>removeEventListener()</code>来移除；移除时传入的参数与添加处理程序时使用的参数相同。这也意味着通过 <code>addEventListener()</code>添加的匿名函数将无法移除.</p></li><li><p><code>event.target</code>指向真正触发事件的元素,<code>event.currentTarget</code>始终指向<code>this</code>.</p></li></ul><h3 id="13-5"><a href="#13-5" class="headerlink" title="13.5"></a>13.5</h3><ul><li>为了避免导致”空事件处理程序”,最好在卸载页面的时候调用<code>onunload</code>移除所有的事件处理程序.</li></ul><h2 id="Chapter-17"><a href="#Chapter-17" class="headerlink" title="Chapter 17"></a>Chapter 17</h2><h3 id="17-2"><a href="#17-2" class="headerlink" title="17.2"></a>17.2</h3><ul><li><blockquote><p>请读者务必要记住，只要代码中包含<code>finally</code>子句，那么无论<code>try</code>还是<code>catch</code>语句块 中的<code>return</code>语句都将被忽略。因此，在使用<code>finally</code>子句之前，一定要非常清楚你想让代码怎么样。</p></blockquote></li><li><p>在<code>throw</code>的时候可以抛出任意类型的值,但是使用内置类型错误,可以更真实的模拟浏览器错误.</p></li><li><p>可以通过原型继承来自定义错误机制.</p></li><li><blockquote><p>说到抛出错误与捕获错误，我们认为只应该捕获那些你确切地知道该如何处理的错误。捕获错误的<br>目的在于避免浏览器以默认方式处理它们；而抛出错误的目的在于提供错误发生具体原因的消息。</p></blockquote></li><li><blockquote><p>任何没有通过<code>try-catch</code>处理的错误都会触发<code>window</code>对象的<code>error</code>事件。只要发生错误，无论是不是浏览器生成的，都会触发<code>error</code>事件，并执行这个事件处理程序。然后，浏览器默认的机制发挥作用，像往常一样显示出错误消息。像下面这样在事件处理程序中返回<code>false</code>，可以阻止浏览器报告错误的默认行为。</p></blockquote></li><li><blockquote><p>大体上来说，基本类型的值应该使用<code>typeof</code>来检测，而对象的值则应该使用<code>instanceof</code>来检测。根据使用函数的方式，有时候并不需要逐个检测所有参数的数据类型。但是，面向公众的 API 则必须无条件地执行类型检查，以确保函数始终能够正常地执行。</p></blockquote></li></ul><h2 id="Chapter-20"><a href="#Chapter-20" class="headerlink" title="Chapter 20"></a>Chapter 20</h2><h3 id="20-1"><a href="#20-1" class="headerlink" title="20.1"></a>20.1</h3><ul><li><blockquote><p>关于 JSON，最重要的是要理解它是一种<strong>数据格式，不是一种编程语言</strong>。虽然具有相同的语法形式，<br>但 JSON 并不从属于 JavaScript。而且，并不是只有 JavaScript 才使用 JSON，毕竟 JSON 只是一种数据<br>格式。很多编程语言都有针对 JSON 的解析器和序列化器。</p></blockquote></li><li><p>JSON支持简单值,对象,数组,但是不支持JS的特殊值<code>undefined</code>(毕竟JSON是通用的).</p></li><li><p>JSON的字符串必须使用双引号.</p></li><li><p>JSON在描述对象的属性键值对时,必须给属性加双引号.</p></li><li><blockquote><p>对象和数组通常是 JSON 数据结构的最外层形式（当然，这不是强制规定的），利用它们能够创造出各种各样的数据结构。</p></blockquote></li><li><blockquote><p>默认情况下， <code>JSON.stringify()</code>输出的 JSON 字符串不包含任何空格字符或缩进，在序列化 JavaScript 对象时，所有函数及原型成员都会被有意忽略，不体现在结果中。此外，值为<code>undefined</code>的任何属性也都会被跳过。结果中最终都是值为有效 JSON 数据类型的实例属性。如果传给 <code>JSON.parse()</code>的字符串不是有效的 JSON，该方法会抛出错误。</p></blockquote></li></ul><h2 id="Chapter-24"><a href="#Chapter-24" class="headerlink" title="Chapter 24"></a>Chapter 24</h2><h3 id="24-1"><a href="#24-1" class="headerlink" title="24.1"></a>24.1</h3><ul><li><blockquote><p>勿将<code>event</code>对象传给其他方法；只传来自<code>event</code>对象中所需的数据；</p><p>任何可以在应用层面的动作都应该可以在不执行任何事件处理程序的情况下进行；</p><p>任何事件处理程序都应该处理事件，然后将处理转交给应用逻辑。</p></blockquote></li><li><blockquote><p>如果看到了与 null 比较的代码，尝试使用以下技术替换：</p><ul><li>如果值应为一个引用类型，使用<code>instanceof</code>操作符检查其构造函数；</li></ul><ul><li>如果值应为一个基本类型，使用<code>typeof</code>检查其类型；</li><li>如果是希望对象包含某个特定的方法名，则使用<code>typeof</code>操作符确保指定名字的方法存在于对</li></ul><p>象上。</p></blockquote></li><li><blockquote><p> 用户界面字符串 —— 任何用于显示给用户的字符串，都应被抽取出来以方便国际化。</p></blockquote></li></ul><h3 id="24-2"><a href="#24-2" class="headerlink" title="24.2"></a>24.2</h3><ul><li><blockquote><p>避免全局查找</p></blockquote><p>比如如果需要多次引用<code>document.getElementById()</code>就可以在局部作用域中使用<code>var doc = document</code>来减少在作用域链上的查找.</p></li><li><blockquote><p>和函数类似， <code>with</code>语句会创建自己的作用域，因此会增加其中执行的代码的作用域链的长度。由于额外的作用域链查找，在 with 语句中执行的代码肯定会比外面执行的代码要慢。</p></blockquote></li><li><p>访问对象的属性是一个O(n)复杂度的操作,所以最好是声明一个变量进行引用.</p></li><li><blockquote><p>如果有一系列复杂的 if-else 语句，可以转换成单个<code>switch</code>语句则可以得到更快的代码。</p></blockquote></li><li><blockquote><p>对于大的 DOM 更改，使用<code>innerHTML</code>比使用标准 DOM 方法创建同样的 DOM 结构快得多。当把innerHTML 设置为某个值时，后台会创建一个 HTML 解析器，然后使用内部的 DOM 调用来创建 DOM 结构，而非基于 JavaScript 的 DOM 调用。由于内部方法是编译好的而非解释执行的，所以执行快得多。</p></blockquote></li><li><blockquote><p>任何时候要访问<code>HTMLCollection</code>，不管它是一个属性还是一个方法，都是在文档上进行一个查询，这个查询开销很昂贵。最小化访问<code>HTMLCollection</code>的次数可以极大地改进脚本的性能。</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Chapter1&quot;&gt;&lt;a href=&quot;#Chapter1&quot; class=&quot;headerlink&quot; title=&quot;Chapter1&quot;&gt;&lt;/a&gt;Chapter1&lt;/h2&gt;&lt;h3 id=&quot;1-2&quot;&gt;&lt;a href=&quot;#1-2&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://fi3ework.github.io/tags/JavaScript/"/>
    
      <category term="读书" scheme="https://fi3ework.github.io/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>CSS中的float和clear</title>
    <link href="https://fi3ework.github.io/2017-02-07/float%E7%90%86%E8%A7%A3/"/>
    <id>https://fi3ework.github.io/2017-02-07/float理解/</id>
    <published>2017-02-07T14:55:21.000Z</published>
    <updated>2017-06-06T16:06:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSS中的float和clear"><a href="#CSS中的float和clear" class="headerlink" title="CSS中的float和clear"></a>CSS中的float和clear</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>float是CSS中相当重要的属性，很惭愧只学了个皮毛，找个机会认真的学习一下float，以后就不要再在float的坑中摔倒了，那么开始。</p><h2 id="1-float的定义"><a href="#1-float的定义" class="headerlink" title="1. float的定义"></a>1. float的定义</h2><p>从网上搜了一个中文版对float的定义，出处已无法考证</p><blockquote><p>CSS样式的float浮动属性，用于设置标签对象的浮动布局，浮动也就是我们所说标签对象浮动居左靠左和浮动居右靠右。</p></blockquote><p>从<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/float" target="_blank" rel="external"><strong>MDN</strong></a>中找了一个相对“官方”的定义。</p><blockquote><p>The float CSS property specifies that an element should be taken from the normal flow and placed along the left or right side of its container, where text and inline elements will wrap around it.</p></blockquote><p>和中文版的定义说的其实差不多，没有什么必要纠结。</p><h2 id="2-float的各种属性"><a href="#2-float的各种属性" class="headerlink" title="2. float的各种属性"></a>2. float的各种属性</h2><h3 id="2-1-MDN"><a href="#2-1-MDN" class="headerlink" title="2.1 MDN"></a>2.1 MDN</h3><p>继续往下看MDN，<br><img src="/2017-02-07/float理解/pic3.png" alt="pic3"><br>默认值为none，对所有非display: none的元素都适用，默认不继承。  </p><blockquote><p>As float implies the use of the block layout, it modifies the computed value of the display values in some cases:</p></blockquote><p>应用float属性的元素将会应用block layout，将改变元素display的计算值。<br><img src="/2017-02-07/float理解/pic4.png" alt="pic4"></p><blockquote><p><strong>left</strong><br>Is a keyword indicating that the element must float on the left side of its containing block.<br><strong>right</strong><br>Is a keyword indicating that the element must float on the right side of its containing block.<br><strong>none</strong><br>Is a keyword indicating that the element must not float.</p></blockquote><p>就是一些比较基本的概念，浮动到所在容器的左侧（右侧）。  </p><h3 id="2-2-W3"><a href="#2-2-W3" class="headerlink" title="2.2 W3"></a>2.2 W3</h3><p>MDN似乎没有什么特别有用的信息，再去看W3的<a href="https://www.w3.org/TR/CSS21/visuren.html#propdef-clear" target="_blank" rel="external">文档</a>中对float的定义，毕竟文档是最权威的。<br>文档中写道</p><blockquote><p>This property specifies whether a box should float to the left, right, or not at all. It may be set for any element, but only applies to elements that generate boxes that are not absolutely positioned. </p></blockquote><p>即float对绝对定位的元素不起作用。 </p><p>到<strong>这里float基本用法可以参见：</strong><a href="http://www.cnblogs.com/polk6/p/3142187.html#Menu2-floatLeft" target="_blank" rel="external"><strong>CSS float 浮动属性</strong></a></p><p>接下来再仔细看float的nine rules：</p><h4 id="rule1"><a href="#rule1" class="headerlink" title="rule1"></a>rule1</h4><blockquote><p>The left outer edge of a left-floating box may not be to the left of the left edge of its containing block. An analogous rule holds for right-floating elements.</p></blockquote><p><strong>左浮动盒子的左边界不会超出其容器的左边界，同理右浮动。</strong><br>很好理解，浮动的边界即为其父元素的边界。</p><h4 id="rule2"><a href="#rule2" class="headerlink" title="rule2"></a>rule2</h4><blockquote><p>If the current box is left-floating, and there are any left-floating boxes generated by elements earlier in the source document, then for each such earlier box, either the left outer edge of the current box must be to the right of the right outer edge of the earlier box, or its top must be lower than the bottom of the earlier box. Analogous rules hold for right-floating boxes.</p></blockquote><p><strong>如果某个盒子是左浮动的，它之前有左浮动盒子，那么他一定在之前的浮动盒子的右边界右边，或者在其底边界的下面，同理右边界。</strong><br>这个规则很关键，其中很容易被忽视的一点就是：这个规则对浮动元素之前的<strong>所有</strong>浮动元素都有效。</p><h4 id="rule3"><a href="#rule3" class="headerlink" title="rule3"></a>rule3</h4><blockquote><p>The right outer edge of a left-floating box may not be to the right of the left outer edge of any right-floating box that is next to it. Analogous rules hold for right-floating elements.</p></blockquote><p>一个左浮动盒子right outer edge可能不挨着一个紧随其后的右浮动盒子的left outer edge的左边。同理右浮动。（讲真，不理解这个rule到底在说啥…）</p><h4 id="rule4"><a href="#rule4" class="headerlink" title="rule4"></a>rule4</h4><blockquote><p>A floating box’s outer top may not be higher than the top of its containing block. When the float occurs between two collapsing margins, the float is positioned as if it had an otherwise empty anonymous block parent taking part in the flow. The position of such a parent is defined by the rules in the section on margin collapsing.</p></blockquote><p>浮动盒子的顶边界不能超过其容器。当？？？</p><h4 id="rule5"><a href="#rule5" class="headerlink" title="rule5"></a>rule5</h4><blockquote><p>The outer top of a floating box may not be higher than the outer top of any block or floated box generated by an element earlier in the source document.</p></blockquote><p>浮动盒子的的顶边界不会高过任何在文档中位于它之前的块级元素或浮动盒子的顶边界。<br><strong>文档流中出现的顺序对float的效果产生了重要的影响，很多时候都是文档流的顺序决定float的效果</strong></p><h4 id="rule-6"><a href="#rule-6" class="headerlink" title="rule 6"></a>rule 6</h4><blockquote><p>The outer top of an element’s floating box may not be higher than the top of any line-box containing a box generated by an element earlier in the source document.</p></blockquote><p>浮动盒子的顶边界不会比任何在文档中位于它之前的包含box的line-box的顶边界高。<br>对line box的理解可以看 <a href="http://www.zhangxinxu.com/wordpress/2010/01/css-float%E6%B5%AE%E5%8A%A8%E7%9A%84%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6%E3%80%81%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%8B%93%E5%B1%95%E4%B8%80/" target="_blank" rel="external"><strong>CSS float浮动的深入研究、详解及拓展(一)</strong></a>，讲的非常详细。</p><h4 id="rule7"><a href="#rule7" class="headerlink" title="rule7"></a>rule7</h4><blockquote><p>A left-floating box that has another left-floating box to its left may not have its right outer edge to the right of its containing block’s right edge. (Loosely: a left float may not stick out at the right edge, unless it is already as far to the left as possible.) An analogous rule holds for right-floating elements.</p></blockquote><p>老实说，没看懂，看其他人的翻译是</p><blockquote><p>就是如果一行之内要放第二个浮动元素，如果放不下了，那就换行。</p></blockquote><h4 id="rule8"><a href="#rule8" class="headerlink" title="rule8"></a>rule8</h4><blockquote><p>A floating box must be placed as high as possible.</p></blockquote><p>一个浮动盒子应该尽可能放的高。</p><h4 id="rule9"><a href="#rule9" class="headerlink" title="rule9"></a>rule9</h4><blockquote><p>A left-floating box must be put as far to the left as possible, a right-floating box as far to the right as possible. A higher position is preferred over one that is further to the left/right.</p></blockquote><p>左浮动的盒子应尽可能往左放，同理右浮动。当元素既可以放置的更“高”，也能放置的更“左/右”时，应优先放的更“高”。</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="case1"><a href="#case1" class="headerlink" title="case1"></a>case1</h3><p><img src="/2017-02-07/float理解/show1.png" alt="showpic1"><br>代码很简单，就不帖了，在一个container里有div1~div5，都具有float: left属性（为了看清楚每个div我都加了10px的margin）。div1和div2很好理解，div1脱离文档流，浮动到最左边，右边有足够的空间，所以div2在div1的右边排列。div3也依次排列。<br>到了div4，由于右边的位置不够，div4只能换行，那么为什么div4在这个位置呢？因为根据rule9，高度优先，所以div4挤进了div3留下的小空里。<br>然后是div5，我以前一直觉得既然高度优先，div5应该紧贴在div1的下面，但为什么div5的上边界挨着div4的下边界呢（请暂时忽略margin，只是为了演示，不影响原理）？因为根据rule2——如果某个盒子是左浮动的，它之前有左浮动盒子，那么他一定在之前的浮动盒子的右边界右边，或者在其底边界的下面，同理右边界。<strong>在计算一个元素的浮动位置的时候要考虑其位置是否对之前所有的浮动元素符合rule2。</strong>如果div5的上边界紧贴着div1，那么在文档流中位于div4之后的div5就既没有在div4的下边界下面，也没有在div4的右边界右面。所以，div5会以div4的下边界为“界限”，div5的上边界与div4的下边界齐平。</p><h3 id="case2"><a href="#case2" class="headerlink" title="case2"></a>case2</h3><p>html如下</p><pre><code>&lt;div id=&quot;div1&quot;&gt;div1:left&lt;/div&gt;&lt;div id=&quot;div2&quot;&gt;div2:left&lt;/div&gt;&lt;div id=&quot;div3&quot;&gt;div3:left&lt;/div&gt;</code></pre><p><img src="/2017-02-07/float理解/show2.png" alt="show2"><br>float设定如图所示，div3被挤到了第二行因为其在文档流中最后一个出现。<br>调换一下div的顺序</p><pre><code>&lt;div id=&quot;div1&quot;&gt;div1:left&lt;/div&gt;&lt;div id=&quot;div3&quot;&gt;div3:left&lt;/div&gt;&lt;div id=&quot;div2&quot;&gt;div2:left&lt;/div&gt;</code></pre><p><img src="/2017-02-07/float理解/show3.png" alt="show3"><br>这回是div2被挤到了第二行，因为在文档流中最后一个出现。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://www.w3.org/TR/CSS2/visuren.html#float-rules" target="_blank" rel="external">W3 rules</a></li><li><a href="http://blog-qeesung.rhcloud.com/css-float-nine-rules/" target="_blank" rel="external">CSS Float nine rules</a></li><li><a href="http://www.jianshu.com/p/07eb19957991#" target="_blank" rel="external">CSS浮动float详解</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CSS中的float和clear&quot;&gt;&lt;a href=&quot;#CSS中的float和clear&quot; class=&quot;headerlink&quot; title=&quot;CSS中的float和clear&quot;&gt;&lt;/a&gt;CSS中的float和clear&lt;/h1&gt;&lt;h2 id=&quot;引言&quot;&gt;&lt;a hr
      
    
    </summary>
    
    
      <category term="CSS" scheme="https://fi3ework.github.io/tags/CSS/"/>
    
  </entry>
  
</feed>
